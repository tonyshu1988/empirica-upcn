/******************************************************************************/
/***       Generated by IBExpert 2009.10.29 23/01/2012 09:38:53 a.m.        ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES NONE;

CREATE DATABASE 'C:\SISTEMAS\SiGeFa\Bases\SiGeFaVacia.FDB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 16384
DEFAULT CHARACTER SET NONE;



/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION ABS
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_abs' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ACOS
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_acos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ADDDAY
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDHOUR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addHour' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMILLISECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMINUTE
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMONTH
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDSECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDWEEK
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDYEAR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addYear' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADD_USER
    INTEGER,
    CSTRING(255),
    CSTRING(31),
    CSTRING(8),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(8)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_add_user' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ASCII_CHAR
    INTEGER
    RETURNS CSTRING(1) FREE_IT
    ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ASCII_VAL
    CHAR(1)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_ascii_val' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ASIN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_asin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ATAN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_atan' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ATAN2
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_atan2' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BIN_AND
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_and' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION BIN_OR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_or' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION BIN_XOR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_xor' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION BITAND
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitAnd' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITNOT
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitNot' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITOR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitOr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITXOR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitXor' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LINE
    BLOB,
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_b_line' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LINE_COUNT
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_line_count' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LONGLINE
    BLOB,
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_b_longline' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LONGSUBSTR
    BLOB,
    INTEGER,
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_b_longsubstr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_MAX_SEGMENT
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_max_segment' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_NUMBER_SEGMENTS
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_number_segments' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_PUT_SEGMENT
    CSTRING(16383),
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'fn_b_put_segment' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_STRCMP
    BLOB,
    BLOB
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_b_strcmp' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_STRPOS
    CSTRING(16383),
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_strpos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_SUBSTR
    BLOB,
    INTEGER,
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_b_substr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_TEXTPOS
    CSTRING(16383),
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_textpos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_TOTAL_LENGTH
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_total_length' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION C
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_c' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CALCEXPR
    CSTRING(16383),
    CSTRING(16383)
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_CalcExpr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CEIL
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_ceil' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CEILING
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_ceiling' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION CEQUAL
    CSTRING(16383),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_cequal' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CHR
    SMALLINT
    RETURNS CSTRING(1) FREE_IT
    ENTRY_POINT 'fn_chr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CIF
    INTEGER,
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_cif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CONVERTSYMBOLS
    CSTRING(255),
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_convertsymbols' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION COS
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_cos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION COSH
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_cosh' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION COT
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cot' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION CREATEGUID

    RETURNS CSTRING(38) FREE_IT
    ENTRY_POINT 'fn_CreateGUID' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DATETODOUBLE
    TIMESTAMP
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_datetodouble' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DATETOSTR
    TIMESTAMP,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_datetostr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DAYPERMONTH
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_daypermonth' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DAYSBETWEEN
    TIMESTAMP,
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_daysbetween' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DELETE_USER
    INTEGER,
    CSTRING(255),
    CSTRING(31),
    CSTRING(31),
    CSTRING(8)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_delete_user' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DIF
    INTEGER,
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_dif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DIV
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_div' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DNULLIF
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DNVL
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DOUBLETODATE
    DOUBLE PRECISION
    RETURNS TIMESTAMP FREE_IT
    ENTRY_POINT 'fn_doubletodate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DOUBLETOTIME
    DOUBLE PRECISION
    RETURNS TIMESTAMP FREE_IT
    ENTRY_POINT 'fn_doubletotime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DOW
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_dow' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DPOWER
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'power' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DTEQUAL
    TIMESTAMP,
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_dtequal' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DTIF
    INTEGER,
    TIMESTAMP,
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_dtif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DZERO
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_dividezero' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION E

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_e' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EAN13CS
    CSTRING(255)
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_ean13cs' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ENCODEDATE
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS TIMESTAMP FREE_IT
    ENTRY_POINT 'fn_encodedate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ENCODEDATETIME
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS TIMESTAMP FREE_IT
    ENTRY_POINT 'fn_encodedatetime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXP
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_exp' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXPRISVALID
    CSTRING(16383),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_ExprIsValid' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTDATE
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_extractdate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTDAY
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_day' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTHOUR
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_hour' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTMILLISECOND
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_millisecond' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTMINUTE
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_minute' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTMONTH
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_month' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTSECOND
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_second' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTTIME
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_extracttime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTWEEKDAY
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_weekday' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTYEAR
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_year' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTYEARDAY
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_yearday' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FCLOSE
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fclose' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FCREATE
    CSTRING(255),
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fcreate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FIRSTDAYMONTH
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_firstdaymonth' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FLOATTOSTR
    DOUBLE PRECISION,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_floattostr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FLOOR
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_floor' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FOPEN
    CSTRING(255),
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fopen' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_APPEND

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_append' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_CREAT

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_creat' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_EXCL

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_excl' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_RDONLY

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_rdonly' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_RDWR

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_rdwr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_TRUNC

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_trunc' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_WRONLY

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_wronly' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FREAD
    INTEGER,
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_fread' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FREMOVE
    CSTRING(255)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fremove' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK_CUR

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek_cur' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK_END

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek_end' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK_SET

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek_set' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSIZE
    CSTRING(255)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fsize' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FS_IEXEC

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fs_iexec' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FS_IREAD

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fs_iread' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FS_IWRITE

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fs_iwrite' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FWRITE
    INTEGER,
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fwrite' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION GETBIT
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_getBit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION GETEXACTTIMESTAMP
    TIMESTAMP
    RETURNS PARAMETER 1
    ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION GETRANDOM
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_getRandom' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION I64NULLIF
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS NUMERIC(18,4) BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NVL
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS NUMERIC(18,0) BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64ROUND
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbround' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64TRUNCATE
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION IEQUAL
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_iequal' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION IIF
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_iif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INCDATE
    TIMESTAMP,
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_incdate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INCDATETIME
    TIMESTAMP,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_incdatetime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INITRANDOM
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_initRandom' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INTTOSTR
    INTEGER,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_inttostr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INULLIF
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INVL
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ISLEAPYEAR
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_isleapyear' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LASTDAYMONTH
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_lastdaymonth' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LIBNAME

    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_libname' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LIBVERSION

    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_libversion' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_ln' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LOG
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_log' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LOG10
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_log10' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGC
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_c' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGCIF
    INTEGER,
    CSTRING(16383),
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_cif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGCONVERTSYMBOLS
    CSTRING(16383),
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_convertsymbols' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGFREAD
    INTEGER,
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_fread' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGLTRIM
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_ltrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGPADLEFT
    CSTRING(16383),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longpadleft' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGPADRIGHT
    CSTRING(16383),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longpadright' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGREPEATTRIM
    CSTRING(16383),
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_repeattrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRLATIN
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rlatin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRLOWER
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rlower' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRTRANSLIT
    CSTRING(16383)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longrtranslit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRTRIM
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rtrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRUPPER
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rupper' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSTRREPEAT
    CSTRING(16383),
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longstrrepeat' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSTRREPLACE
    CSTRING(16383),
    CSTRING(16383),
    CSTRING(16383)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longstrreplace' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSTRSTUFF
    CSTRING(16383),
    INTEGER,
    INTEGER,
    CSTRING(16383)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longstrstuff' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSUBSTR
    CSTRING(16383),
    INTEGER,
    INTEGER
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_substr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGTRIM
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_trim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGWORDNUM
    CSTRING(16383),
    INTEGER,
    CSTRING(31),
    SMALLINT
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_wordnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LOWER
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_lower' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LPAD
    CSTRING(255),
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LTRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_ltrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MAXDATE
    TIMESTAMP,
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_maxdate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MAXNUM
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_maxnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5FINAL
    CSTRING(176)
    RETURNS CSTRING(32) FREE_IT
    ENTRY_POINT 'fn_md5final' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5INIT

    RETURNS CSTRING(176) FREE_IT
    ENTRY_POINT 'fn_md5init' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5SUM
    CSTRING(16383)
    RETURNS CSTRING(32) FREE_IT
    ENTRY_POINT 'fn_md5sum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5UPDATE
    CSTRING(176),
    CSTRING(16383),
    INTEGER
    RETURNS CSTRING(176)
    ENTRY_POINT 'fn_md5update' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MINDATE
    TIMESTAMP,
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_mindate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MINNUM
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_minnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MOD
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_mod' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MODIFY_USER
    INTEGER,
    CSTRING(255),
    CSTRING(31),
    CSTRING(8),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(8)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_modify_user' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MSGBOX
    CSTRING(16383),
    CSTRING(255),
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_msgbox' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION NUMINWORDS
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_numinwords' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ORD
    CSTRING(1)
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_ord' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION PADLEFT
    CSTRING(255),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_padleft' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION PADRIGHT
    CSTRING(255),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_padright' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION PI

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_pi' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION POWER
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_power' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION QUARTER
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_quarter' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RAND

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_rand' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION REPEATTRIM
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_repeattrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RLATIN
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rlatin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RLOWER
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rlower' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ROUND
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_round' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RPAD
    CSTRING(255),
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION RTRANSLIT
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_rtranslit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RTRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rtrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RUPPER
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rupper' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SDOW
    TIMESTAMP,
    VARCHAR(5)
    RETURNS PARAMETER 2
    ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SETBIT
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_setBit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SIGN
    DOUBLE PRECISION
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_sign' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SIN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_sin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SINH
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_sinh' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SNULLIF
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SNVL
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SOFTROUND
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_softround' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SQRT
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_sqrt' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SRIGHT
    VARCHAR(100) BY DESCRIPTOR,
    SMALLINT,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'right' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRCMP
    CSTRING(16383),
    CSTRING(16383)
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_strcmp' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRCOUNT
    CSTRING(255),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_strcount' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRING2BLOB
    VARCHAR(300) BY DESCRIPTOR,
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRLEN
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_strlen' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRPOS
    CSTRING(16383),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_strpos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRREPEAT
    CSTRING(255),
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_strrepeat' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRREPLACE
    CSTRING(255),
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_strreplace' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRSTUFF
    CSTRING(255),
    INTEGER,
    INTEGER,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_strstuff' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRTRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_trim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SUBSTR
    CSTRING(255),
    INTEGER,
    INTEGER
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_substr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SUBSTRLEN
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION TAN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_tan' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION TANH
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_tanh' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION TIMETODOUBLE
    TIMESTAMP
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_timetodouble' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION TRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_trim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION TRUNCATE
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION WORDCOUNT
    CSTRING(16383),
    CSTRING(31),
    SMALLINT
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_wordcount' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION WORDNUM
    CSTRING(16383),
    INTEGER,
    CSTRING(31),
    SMALLINT
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_wordnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION Z
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_z' MODULE_NAME 'rfunc';




/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/

CREATE DOMAIN FISCAL AS
NUMERIC(15,2);



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_ARTICULO_ID;
SET GENERATOR GEN_ARTICULO_ID TO 0;

CREATE GENERATOR GEN_CAJA_NRO_ID;
SET GENERATOR GEN_CAJA_NRO_ID TO 0;

CREATE GENERATOR GEN_COLOR_ID;
SET GENERATOR GEN_COLOR_ID TO 0;

CREATE GENERATOR GEN_COMPROBANTE_DETALLE_ID;
SET GENERATOR GEN_COMPROBANTE_DETALLE_ID TO 0;

CREATE GENERATOR GEN_COMPROBANTE_ESTADO_ID;
SET GENERATOR GEN_COMPROBANTE_ESTADO_ID TO 0;

CREATE GENERATOR GEN_COMPROBANTE_FORMA_PAGO_ID;
SET GENERATOR GEN_COMPROBANTE_FORMA_PAGO_ID TO 0;

CREATE GENERATOR GEN_COMPROBANTE_ID;
SET GENERATOR GEN_COMPROBANTE_ID TO 0;

CREATE GENERATOR GEN_CUENTA_CORRIENTE_ID;
SET GENERATOR GEN_CUENTA_CORRIENTE_ID TO 0;

CREATE GENERATOR GEN_CUENTA_ID;
SET GENERATOR GEN_CUENTA_ID TO 0;

CREATE GENERATOR GEN_EMPRESA_ID;
SET GENERATOR GEN_EMPRESA_ID TO 0;

CREATE GENERATOR GEN_EMPRESA_MARCA_ID;
SET GENERATOR GEN_EMPRESA_MARCA_ID TO 0;

CREATE GENERATOR GEN_ENTIDAD_TELEFONOS_ID;
SET GENERATOR GEN_ENTIDAD_TELEFONOS_ID TO 0;

CREATE GENERATOR GEN_MAIL_ADJUNTOS_ID;
SET GENERATOR GEN_MAIL_ADJUNTOS_ID TO 0;

CREATE GENERATOR GEN_MAIL_CUENTAS_ID;
SET GENERATOR GEN_MAIL_CUENTAS_ID TO 0;

CREATE GENERATOR GEN_MAIL_MENSAJE_ID;
SET GENERATOR GEN_MAIL_MENSAJE_ID TO 0;

CREATE GENERATOR GEN_MARCA_ID;
SET GENERATOR GEN_MARCA_ID TO 0;

CREATE GENERATOR GEN_MEDIDA_ARTICULO_ID;
SET GENERATOR GEN_MEDIDA_ARTICULO_ID TO 0;

CREATE GENERATOR GEN_MEDIDA_ID;
SET GENERATOR GEN_MEDIDA_ID TO 0;

CREATE GENERATOR GEN_PAGO_FACTURAS_ID;
SET GENERATOR GEN_PAGO_FACTURAS_ID TO 0;

CREATE GENERATOR GEN_PERSONA_ID;
SET GENERATOR GEN_PERSONA_ID TO 0;

CREATE GENERATOR GEN_PERSONA_PUNTOS_ID;
SET GENERATOR GEN_PERSONA_PUNTOS_ID TO 0;

CREATE GENERATOR GEN_PERSONA_RELACION_ID;
SET GENERATOR GEN_PERSONA_RELACION_ID TO 1;

CREATE GENERATOR GEN_POSICION_SUCURSAL_ID;
SET GENERATOR GEN_POSICION_SUCURSAL_ID TO 1;

CREATE GENERATOR GEN_PRECIO_ID;
SET GENERATOR GEN_PRECIO_ID TO 0;

CREATE GENERATOR GEN_PRODUCTO_CABECERA_ID;
SET GENERATOR GEN_PRODUCTO_CABECERA_ID TO 0;

CREATE GENERATOR GEN_PRODUCTO_ID;
SET GENERATOR GEN_PRODUCTO_ID TO 0;

CREATE GENERATOR GEN_STOCK_PRODUCTO_ID;
SET GENERATOR GEN_STOCK_PRODUCTO_ID TO 0;

CREATE GENERATOR GEN_SUCURSAL_ID;
SET GENERATOR GEN_SUCURSAL_ID TO 0;

CREATE GENERATOR GEN_TIPO_ARTICULO_ID;
SET GENERATOR GEN_TIPO_ARTICULO_ID TO 0;

CREATE GENERATOR GEN_TIPO_COMPROBANTE_ID;
SET GENERATOR GEN_TIPO_COMPROBANTE_ID TO 0;

CREATE GENERATOR GEN_TIPO_DOCUMENTO_ID;
SET GENERATOR GEN_TIPO_DOCUMENTO_ID TO 0;

CREATE GENERATOR GEN_TIPO_EMPRESA_ID;
SET GENERATOR GEN_TIPO_EMPRESA_ID TO 0;

CREATE GENERATOR GEN_TIPO_FORMAPAGO_ID;
SET GENERATOR GEN_TIPO_FORMAPAGO_ID TO 0;

CREATE GENERATOR GEN_TIPO_IVA_ID;
SET GENERATOR GEN_TIPO_IVA_ID TO 0;

CREATE GENERATOR GEN_TIPO_MOVIMIENTO_ID;
SET GENERATOR GEN_TIPO_MOVIMIENTO_ID TO 0;

CREATE GENERATOR GEN_TIPO_RELACION_ID;
SET GENERATOR GEN_TIPO_RELACION_ID TO 0;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION ERROR '';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE AA_CORREGIR_PRECIOS_NUEVA_TABLA
RETURNS (
    TOT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AAAA_ASOCIAR_PRDO_STOCK (
    ID_SUCURSAL INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE AAAAA_ACTUALIZAR_TELEFONO
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ACOMODAR_INDICES
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ACTIVAR_TRIGGERS (
    TIPO VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ACTUALIZAR_BASE
RETURNS (
    ACTUALIZACION VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ACTUALIZAR_IMPORTES (
    COEF_AUMENTO_COSTO NUMERIC(15,4),
    COEF_AUMENTO_VENTA NUMERIC(15,4),
    ID_PRECIO INTEGER,
    TIPOCALCULO INTEGER,
    ACTUALIZAR_IMPUESTOS INTEGER,
    IMPUESTO_IVA NUMERIC(15,4),
    IMPUESTO_ADICIONAL1 NUMERIC(15,4),
    IMPUESTO_ADICIONAL2 NUMERIC(15,4),
    PRECIO1 NUMERIC(15,4),
    PRECIO2 NUMERIC(15,4),
    PRECIO3 NUMERIC(15,4),
    PRECIO4 NUMERIC(15,4),
    PRECIO5 NUMERIC(15,4))
RETURNS (
    SALIDA INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ACUMULAR_PERSONA_PUNTOS (
    ID_PERSONA_COMPRA INTEGER,
    MONTO_COMPRA NUMERIC(15,2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ASOCIAR_PRODUCTO_PTO_SALIDA (
    ID_PRODUCTO INTEGER,
    STOCK_ACTUAL NUMERIC(15,4),
    STOCK_MIN NUMERIC(15,4),
    STOCK_MAX NUMERIC(15,4))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE CALC_CTACTE_GENERAL (
    TIPO INTEGER)
RETURNS (
    ID_PERSONA INTEGER,
    ID_PROVEEDOR INTEGER,
    VENCIMIENTO_DIAS INTEGER,
    LIMITE_DEUDA NUMERIC(15,2),
    DEBE NUMERIC(15,2),
    HABER NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    FECHA_ALTA DATE,
    FECHA_BAJA DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CALC_CTACTE_INDIVIDUAL_CLIENTE (
    ID_SUCURSAL INTEGER,
    ID_PERSONA INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE)
RETURNS (
    TIPO_COMPROBANTE VARCHAR(100),
    ID_COMPROBANTE INTEGER,
    ID_COMPROB_FP INTEGER,
    ID_CUENTA INTEGER,
    ID_VENDEDOR INTEGER,
    ID_TIPO_IVA INTEGER,
    ID_TIPO_FP INTEGER,
    FECHA DATE,
    OBSERVACION VARCHAR(500),
    FECHA_FP DATE,
    DEBE NUMERIC(15,4),
    HABER NUMERIC(15,4),
    SALDO_CPB NUMERIC(15,4),
    ORDEN1 INTEGER,
    ORDEN2 INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CALC_CTACTE_INDIVIDUAL_PROV (
    ID_SUCURSAL INTEGER,
    ID_PROVEEDOR INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE)
RETURNS (
    TIPO_COMPROBANTE VARCHAR(30),
    ID_COMPROBANTE INTEGER,
    ID_COMPROB_FP INTEGER,
    ID_CUENTA INTEGER,
    ID_VENDEDOR INTEGER,
    ID_TIPO_IVA INTEGER,
    ID_TIPO_FP INTEGER,
    FECHA DATE,
    OBSERVACION VARCHAR(500),
    FECHA_FP DATE,
    DEBE NUMERIC(15,4),
    HABER NUMERIC(15,4),
    SALDO_CPB NUMERIC(15,4),
    ORDEN1 INTEGER,
    ORDEN2 INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CALC_SALDOS_CUENTAS (
    FECHA_HASTA DATE)
RETURNS (
    GRUPO INTEGER,
    ID_SUCURSAL INTEGER,
    ID_CUENTA INTEGER,
    IMPORTE NUMERIC(15,4))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CORREGIR_PRECIOS_ANTIGUOS
RETURNS (
    SQL VARCHAR(2000))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CTACTA_DEUDA_ATRASADA (
    TIPO INTEGER)
RETURNS (
    ID_CLIENTE INTEGER,
    CODIGO_CORTO INTEGER,
    NOMBRE VARCHAR(200),
    SALDO_CPB NUMERIC(15,4),
    ID_PROVEEDOR INTEGER,
    FECHA_VENCIM DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CTACTA_DEUDA_ATRASADA_CLIENTE (
    ID_CLIENTE INTEGER)
RETURNS (
    ID_CLIENTE_OUT INTEGER,
    CODIGO_CORTO INTEGER,
    NOMBRE VARCHAR(200),
    SALDO_CPB NUMERIC(15,4),
    FECHA_VENCIM DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CTACTA_DEUDA_ATRASADA_PROVEEDOR (
    ID_PROVEEDOR INTEGER)
RETURNS (
    ID_PROVEEDOR_OUT INTEGER,
    CODIGO_CORTO INTEGER,
    NOMBRE VARCHAR(200),
    SALDO_CPB NUMERIC(15,4),
    FECHA_VENCIM DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CTACTE_GENERAL (
    ID_PROVEEDOR INTEGER,
    ID_CLIENTE INTEGER)
RETURNS (
    ID_CLIENTE_OUT INTEGER,
    LIMITE_DEUDA NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    FECHA_ALTA DATE,
    FECHA_BAJA DATE,
    DEBE NUMERIC(15,2),
    HABER NUMERIC(15,2),
    NOMBRE VARCHAR(200),
    NUMERO_DOC VARCHAR(50),
    LOCALIDAD VARCHAR(200),
    CODIGO_POSTAL VARCHAR(20),
    CUIT_CUIL VARCHAR(30),
    BAJA VARCHAR(1),
    NOMBRE_PROVINCIA VARCHAR(50),
    NOMBRE_TIPO_IVA VARCHAR(50),
    COD_IVA VARCHAR(10),
    NOMBRE_TIPO_DOC VARCHAR(20),
    CODIGO_CORTO INTEGER,
    VENCIMIENTO_DIAS INTEGER,
    ID_PROVEEDOR_OUT INTEGER,
    DEUDA_VENCIDA VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CTACTE_INDIVIDUAL (
    ID_SUCURSAL INTEGER,
    ID_CLIENTE INTEGER,
    ID_PROVEEDOR INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE)
RETURNS (
    TIPO_COMPROBANTE VARCHAR(100),
    ID_COMPROBANTE INTEGER,
    ID_CUENTA INTEGER,
    ID_VENDEDOR INTEGER,
    ID_TIPO_IVA INTEGER,
    ID_TIPO_FP INTEGER,
    FECHA DATE,
    OBSERVACION VARCHAR(500),
    FECHA_FP DATE,
    DEBE NUMERIC(15,4),
    HABER NUMERIC(15,4),
    SALDO_CPB NUMERIC(15,4),
    SALDO NUMERIC(15,4),
    ID_COMPROB_FP INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE DESACTIVAR_TRIGGERS (
    TIPO VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE DEVOLUCION_UPDATE_STOCK (
    ID_COMPROBANTE INTEGER,
    ACCION INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ESTADISTICA_DETALLE_MOVIMIENTOS (
    FECHADESDE DATE,
    FECHAHASTA DATE,
    ID_SUCURSAL_INGRESO INTEGER)
RETURNS (
    IMPORTE_VENTA NUMERIC(15,2),
    NUMERO_CPB INTEGER,
    PUNTO_VENTA INTEGER,
    CODIGO VARCHAR(50),
    FECHA TIMESTAMP,
    OBSERVACION VARCHAR(500),
    TIPO_COMPROBANTE VARCHAR(100),
    TIPO_MOVIMIENTO VARCHAR(20),
    NOMBRE_ENTIDAD VARCHAR(100),
    ID_COMPROBANTE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ESTADISTICA_DIARIA_GLOBAL (
    FECHA_DESDE DATE,
    FECHA_HASTA DATE,
    ID_SUCURSAL INTEGER,
    TIPO_CPB INTEGER)
RETURNS (
    FECHA DATE,
    INGRESO NUMERIC(15,2),
    EGRESO NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    SALDODIARIO NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ESTADISTICA_DIARIA_MOV_INTERNOS (
    FECHA_DESDE DATE,
    FECHA_HASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    FECHA DATE,
    INGRESO NUMERIC(15,2),
    EGRESO NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    SALDODIARIO NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ESTADISTICA_IE_MEDIO (
    FECHADESDE DATE,
    FECHAHASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    TOTAL_EGRESO NUMERIC(15,2),
    TOTAL_INGRESO NUMERIC(15,2),
    DESCRIPCION VARCHAR(100),
    TOTAL_TRANSFERENCIA NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ESTADISTICA_PARTE_DIARIO (
    FECHADESDE DATE,
    FECHAHASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    SALDO_INICIAL NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    TOTAL_INGRESO NUMERIC(15,2),
    TOTAL_EGRESO NUMERIC(15,2),
    TOTAL_TRANSFERENCIA NUMERIC(15,2),
    TOTAL_NOTA_CREDITO NUMERIC(15,2),
    TOTAL_CTA_CTE_CLIENTE NUMERIC(15,2),
    TOTAL_CTA_CTE_PROVEEDOR NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ESTADISTICA_VENTAS_POR_HORA (
    INTERVALO INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    HORA_DESDE TIME,
    HORA_HASTA TIME,
    CANTIDAD INTEGER,
    IMPORTE NUMERIC(15,4),
    HORA_PERIODO TIME,
    PERIODO INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GENERAR_STOCK_INICIAL
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE INICIALIZAR_GENERADORES
RETURNS (
    TABLA VARCHAR(31),
    CAMPO_ID VARCHAR(31),
    GENERADOR VARCHAR(31),
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE INSERTAR_SALDO_INICIA_CTA_CTE (
    ID_CLIENTE INTEGER,
    ID_PROVEEDOR INTEGER,
    ID_SUCURSAL INTEGER,
    SALDO_INICIAL NUMERIC(15,2),
    FECHA TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE MARCAR_PUNTO_SALIDA (
    ID_SUCURSAL INTEGER,
    ID_POSICION_SUCURSAL INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE NOTA_PEDIDO_UPDATE_ESTADO (
    ID_COMPROBANTE INTEGER,
    ID_ESTADO INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ORDEN_PAGO_CTA_CTE_ANULAR (
    ID_COMPROBANE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ORDEN_PAGO_CTA_CTE_CONFIRMAR (
    ID_COMPROBANTE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PROCESAR_STOCK (
    ID_STOCK_PROD INTEGER,
    ID_PRODUCTO INTEGER,
    ID_POS_SUC INTEGER,
    CANTIDAD_ALMACENAR FLOAT,
    STOCK_MIN FLOAT,
    STOCK_MAX FLOAT,
    STOCK_REPEDIDO FLOAT,
    ID_COMPROBANTE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE RECIBO_CTA_CTE_ANULAR (
    ID_COMPROBANE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE RECIBO_CTA_CTE_CONFIRMAR (
    ID_COMPROBANTE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SALDOS_CUENTAS (
    ID_SUCURSAL INTEGER,
    FECHA_HASTA DATE)
RETURNS (
    ID_CUENTA INTEGER,
    CODIGO VARCHAR(10),
    NOMBRE_CUENTA VARCHAR(50),
    NRO_CTA_BANCO VARCHAR(10),
    IMPORTE NUMERIC(15,4))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_COLOR_ID
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_COMPROBANTE_ID
RETURNS (
    ID INTEGER,
    CODIGO VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_EMPRESA_ID
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_MAIL_MENSAJE_ID
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_PERSONA_ID
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_PRODUCTO_CABECERA_ID
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GEN_PRODUCTO_ID
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_IMPRIMIR_ETIQUETAS (
    DESDE_RENGLON INTEGER,
    LONG_DESCRIPCION INTEGER)
RETURNS (
    CODIGOBARRA VARCHAR(20),
    ID_PRODUCTO INTEGER,
    DESCRIPCION VARCHAR(200),
    ID_PRECIO INTEGER,
    MEDIDA VARCHAR(30),
    COLOR VARCHAR(30),
    PRECIO NUMERIC(15,2),
    NOMBRE_PRO VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE VACIAR_AUDITORIA (
    USUARIO VARCHAR(67),
    FECHA TIMESTAMP,
    OPERACION VARCHAR(1),
    TABLA VARCHAR(67),
    NO_FECHA VARCHAR(1),
    NO_USUARIO VARCHAR(1),
    NO_OPERACION VARCHAR(1),
    NO_TABLA VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE VALIDAR_DEMO_SISTEMA
RETURNS (
    RESULTADO INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE VER_AUDITORIA_TABLA (
    ID_TABLA INTEGER)
RETURNS (
    CAMPO VARCHAR(67),
    VALOR_NUEVO VARCHAR(255),
    VALOR_VIEJO VARCHAR(255),
    VALOR_REF_NUEVO VARCHAR(255),
    VALOR_REF_VIEJO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE VER_DESTINO_COMPROBANTE (
    ID_PERSONA INTEGER,
    ID_EMPRESA INTEGER)
RETURNS (
    NOMBRE VARCHAR(200),
    DIRECCION VARCHAR(200),
    CODIGO_POSTAL VARCHAR(20),
    LOCALIDAD VARCHAR(200),
    PROVINCIA VARCHAR(50),
    TIPO_DOCUMENTO VARCHAR(20),
    NUMERO_DOCUMENTO VARCHAR(50),
    TIPO_IVA VARCHAR(50),
    CUIT_CUIL VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ARTICULO (
    ID_ARTICULO       INTEGER NOT NULL,
    ID_TIPO_ARTICULO  INTEGER NOT NULL,
    DESCRIPCION       VARCHAR(200),
    BAJA              VARCHAR(1)
);


CREATE TABLE CAJA_NRO (
    ID_CAJA      INTEGER NOT NULL,
    CAJA_NRO     INTEGER,
    DESCRIPCION  VARCHAR(100)
);


CREATE TABLE COLOR (
    ID_COLOR      INTEGER NOT NULL,
    CODIGO_COLOR  INTEGER,
    NOMBRE        VARCHAR(30),
    REFERENCIA    VARCHAR(30),
    BAJA          VARCHAR(1)
);


CREATE TABLE COMPROBANTE (
    ID_COMPROBANTE      INTEGER NOT NULL,
    ID_SUCURSAL         INTEGER NOT NULL,
    ID_PROVEEDOR        INTEGER,
    ID_CLIENTE          INTEGER,
    ID_TIPO_CPB         INTEGER NOT NULL,
    ID_VENDEDOR         INTEGER,
    ID_COMP_ESTADO      INTEGER,
    CODIGO              VARCHAR(50),
    FECHA               TIMESTAMP,
    OBSERVACION         VARCHAR(500),
    BASE_IMPONIBLE      NUMERIC(15,4),
    SALDO               NUMERIC(15,4),
    IMPORTE_TOTAL       NUMERIC(15,4),
    PORC_IVA            NUMERIC(15,4),
    IMPORTE_IVA         NUMERIC(15,4),
    PORC_DESCUENTO      NUMERIC(15,4),
    IMPORTE_DESCUENTO   NUMERIC(15,4),
    ENCABEZADO          VARCHAR(500),
    PIE                 VARCHAR(500),
    FECHA_COBRADA       TIMESTAMP,
    FECHA_ENVIADA       DATE,
    FECHA_IMPRESA       DATE,
    FECHA_VENCIMIENTO   DATE,
    PUNTO_VENTA         INTEGER,
    NUMERO_CPB          INTEGER,
    FECHA_ANULADO       DATE,
    ID_TIPO_IVA         INTEGER,
    ID_TIPO_MOVIMIENTO  INTEGER,
    IMPORTE_VENTA       NUMERIC(15,2),
    IMAGEN              BLOB SUB_TYPE 0 SEGMENT SIZE 80
);


CREATE TABLE COMPROBANTE_DETALLE (
    ID_COMPROBANTE_DETALLE  INTEGER NOT NULL,
    ID_COMPROBANTE          INTEGER,
    ID_PRODUCTO             INTEGER NOT NULL,
    DETALLE                 VARCHAR(200),
    CANTIDAD                NUMERIC(15,2),
    IMPORTE_FINAL           NUMERIC(15,4),
    PORC_DESCUENTO          NUMERIC(15,4),
    BASE_IMPONIBLE          NUMERIC(15,4),
    IMPORTE_UNITARIO        NUMERIC(15,4),
    IMPUESTO_INTERNO        NUMERIC(15,4),
    PORC_IVA                NUMERIC(15,4),
    CANTIDAD_RECIBIDA       NUMERIC(15,2),
    CANTIDAD_ALMACENADA     NUMERIC(15,2),
    ID_STOCK_PRODUCTO       INTEGER,
    IMPORTE_VENTA           NUMERIC(15,4),
    IMPORTE_IVA             NUMERIC(15,4),
    IMPORTE_IF              FISCAL,
    IMPORTE_IF_SINIVA       FISCAL,
    IMPORTE_IVA_IF          FISCAL
);


CREATE TABLE COMPROBANTE_ESTADO (
    ID_COMP_ESTADO  INTEGER NOT NULL,
    DESCRIPCION     VARCHAR(50)
);


CREATE TABLE COMPROBANTE_FORMA_PAGO (
    ID_COMPROB_FP     INTEGER NOT NULL,
    ID_COMPROBANTE    INTEGER,
    ID_TIPO_FORMAPAG  INTEGER NOT NULL,
    MDCP_FECHA        DATE,
    MDCP_BANCO        VARCHAR(50),
    MDCP_CHEQUE       VARCHAR(50),
    IMPORTE           NUMERIC(15,2),
    CONCILIADO        DATE,
    CUENTA_INGRESO    INTEGER,
    CUENTA_EGRESO     INTEGER,
    FECHA_FP          TIMESTAMP,
    IMPORTE_REAL      NUMERIC(15,2),
    ID_RECIBO_OP      INTEGER
);


CREATE TABLE CONFIGURACION (
    DB_SUCURSAL   INTEGER,
    ID_SUCURSAL   INTEGER,
    ULTIMA_FECHA  TIMESTAMP
);


CREATE TABLE CONFIGURACION_VARIABLES (
    CLAVE        VARCHAR(50) NOT NULL,
    FECHA        DATE,
    NUMERO       NUMERIC(15,4),
    TEXTO        VARCHAR(100) DEFAULT '' NOT NULL,
    NIVEL        SMALLINT,
    GRUPO        VARCHAR(50),
    DESCRIPCION  VARCHAR(1000),
    GRAFICO      BLOB SUB_TYPE 0 SEGMENT SIZE 80
);


CREATE TABLE CUENTA (
    ID_CUENTA         INTEGER NOT NULL,
    MEDIO_DEFECTO     INTEGER,
    CODIGO            VARCHAR(10),
    NOMBRE_CUENTA     VARCHAR(50),
    NRO_CTA_BANCARIA  VARCHAR(10),
    BAJA              VARCHAR(1),
    ID_SUCURSAL       INTEGER,
    A_CTA_CORRIENTE   VARCHAR(1),
    A_NOTA_CREDITO    VARCHAR(1),
    MODIFICABLE       VARCHAR(1)
);


CREATE TABLE CUENTA_CORRIENTE (
    ID_CTA_CTE        INTEGER NOT NULL,
    ID_PERSONA        INTEGER,
    ID_PROVEEDOR      INTEGER,
    SALDO             NUMERIC(15,4),
    LIMITE_DEUDA      NUMERIC(15,2),
    VENCIMIENTO_DIAS  INTEGER,
    FECHA_ALTA        DATE,
    FECHA_BAJA        DATE,
    BAJA              VARCHAR(1)
);


CREATE TABLE EMPRESA (
    ID_EMPRESA           INTEGER NOT NULL,
    ID_PROVINCIA         INTEGER,
    ID_TIPO_IVA          INTEGER,
    ID_TIPO_EMPRESA      INTEGER,
    CUIT_CUIL            VARCHAR(30),
    NOMBRE               VARCHAR(200),
    DIRECCION            VARCHAR(200),
    LOCALIDAD            VARCHAR(200),
    CODIGO_POSTAL        VARCHAR(20),
    TELEFONO             VARCHAR(100),
    EMAIL                VARCHAR(100),
    PAGINA_WEB           VARCHAR(200),
    BAJA                 VARCHAR(1),
    DESCRIPCION          VARCHAR(500),
    DESCRIPCION_PRIVADA  VARCHAR(1000),
    CODIGO_CORTO         INTEGER
);


CREATE TABLE EMPRESA_MARCA (
    ID           INTEGER NOT NULL,
    ID_EMPRESA   INTEGER NOT NULL,
    ID_MARCA     INTEGER NOT NULL,
    DESCRIPCION  VARCHAR(500)
);


CREATE TABLE ENTIDAD_TELEFONOS (
    ID_ENTIDAD_TELEFONO  INTEGER NOT NULL,
    ID_ENTIDAD           INTEGER,
    ID_PERSONA           INTEGER,
    TELEFONO             VARCHAR(100),
    MAIL                 VARCHAR(100),
    DESCRIPCION          VARCHAR(100)
);


CREATE TABLE IMPRIMIR_ETIQUETAS (
    ID_PRODUCTO  INTEGER,
    CANTIDAD     INTEGER,
    ID_PRECIO    INTEGER
);


CREATE TABLE MAIL_ADJUNTOS (
    ID_ADJUNTO         INTEGER NOT NULL,
    ID_MAIL            INTEGER,
    NOMBRE             VARCHAR(100),
    UBICACION_ARCHIVO  VARCHAR(200)
);


CREATE TABLE MAIL_CUENTAS (
    ID_CUENTA           INTEGER NOT NULL,
    ID_SUCURSAL         INTEGER,
    EMAIL               VARCHAR(100),
    POP3_HOST           VARCHAR(100),
    POP3_PUERTO         INTEGER,
    POP3_USUARIO        VARCHAR(100),
    POP3_PASSWORD       VARCHAR(100),
    SMTP_HOST           VARCHAR(100),
    SMTP_PUERTO         INTEGER,
    SMTP_USUARIO        VARCHAR(100),
    SMTP_PASSWORD       VARCHAR(100),
    SMTP_AUTENTICACION  VARCHAR(100),
    CUENTA_PRINCIPAL    VARCHAR(1),
    SMTP_SSL            VARCHAR(100),
    POP3_SSL            VARCHAR(100),
    POP3_AUTENTICACION  VARCHAR(100)
);


CREATE TABLE MAIL_MENSAJE (
    ID_MAIL_MENSAJE        INTEGER NOT NULL,
    ID_CUENTA              INTEGER,
    CABECERA_PARA          VARCHAR(500),
    CABECERA_CC            VARCHAR(500),
    CABECERA_CCO           VARCHAR(500),
    CABECERA_ASUNTO        VARCHAR(100),
    CABECERA_PRIORIDAD     VARCHAR(20),
    CABECERA_ACUSE_RECIBO  VARCHAR(1),
    CUERPO                 BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    FECHA_Y_HORA           TIMESTAMP,
    ENVIADO                VARCHAR(1),
    TIPO                   VARCHAR(1)
);


CREATE TABLE MARCA (
    ID_MARCA      INTEGER NOT NULL,
    CODIGO_MARCA  INTEGER,
    NOMBRE_MARCA  VARCHAR(50),
    BAJA          VARCHAR(1)
);


CREATE TABLE MEDIDA (
    ID_MEDIDA  INTEGER NOT NULL,
    MEDIDA     VARCHAR(30),
    BAJA       VARCHAR(1)
);


CREATE TABLE MEDIDA_ARTICULO (
    ID_MEDIDA_ARTICULO  INTEGER NOT NULL,
    ID_ARTICULO         INTEGER NOT NULL,
    ID_MEDIDA           INTEGER NOT NULL,
    BAJA                VARCHAR(1)
);


CREATE TABLE PAGO_FACTURAS (
    ID_PAGO_FACTURAS     INTEGER NOT NULL,
    ID_COMPROBANTE       INTEGER,
    ID_FACTURA           INTEGER,
    ID_TIPO_COMPROBANTE  INTEGER,
    IMPORTE              NUMERIC(15,2)
);


CREATE TABLE PERSONA (
    ID_PERSONA          INTEGER NOT NULL,
    ID_PROVINCIA        INTEGER,
    ID_TIPO_DOC         INTEGER,
    ID_TIPO_IVA         INTEGER,
    NOMBRE              VARCHAR(200),
    DIRECCION           VARCHAR(200),
    LOCALIDAD           VARCHAR(200),
    CODIGO_POSTAL       VARCHAR(20),
    TELEFONO            VARCHAR(100),
    EMAIL               VARCHAR(100),
    FECHA_NACIMIENTO    DATE,
    NUMERO_DOC          VARCHAR(50),
    SEXO                VARCHAR(1),
    BAJA                VARCHAR(1),
    DESCRIPCION         VARCHAR(500),
    CUIT_CUIL           VARCHAR(30),
    DESCUENTO_ESPECIAL  NUMERIC(15,4),
    CODIGO_CORTO        INTEGER,
    CODIGO_BARRA        VARCHAR(40)
);


CREATE TABLE PERSONA_PUNTOS (
    ID_PERSONA_PUNTO    INTEGER NOT NULL,
    ID_PERSONA          INTEGER,
    MONTO               NUMERIC(15,2),
    PUNTOS_MAYOR_MONTO  NUMERIC(15,2),
    PUNTOS_MENOR_MONTO  NUMERIC(15,2),
    PUNTOS_ACUMULADOS   NUMERIC(15,2),
    BAJA                VARCHAR(1)
);


CREATE TABLE PERSONA_RELACION (
    ID_PERSONA_RELACION  INTEGER NOT NULL,
    ID_PERSONA           INTEGER NOT NULL,
    ID_RELACION          INTEGER NOT NULL,
    ID_EMPRESA           INTEGER,
    ID_SUCURSAL          INTEGER
);


CREATE TABLE POSICION_SUCURSAL (
    ID_POSICION_SUCURSAL  INTEGER NOT NULL,
    ID_SUCURSAL           INTEGER NOT NULL,
    SECCION               VARCHAR(50),
    SECTOR                VARCHAR(10),
    FILA                  VARCHAR(10),
    COLUMNA               VARCHAR(10),
    BAJA                  VARCHAR(1),
    PUNTO_SALIDA          VARCHAR(1)
);


CREATE TABLE PRECIO (
    ID_PRECIO                INTEGER NOT NULL,
    ID_PRODUCTO              INTEGER,
    ID_SUCURSAL              INTEGER,
    PRECIO_COSTO             FISCAL,
    PRECIO_VENTA             FISCAL,
    COEF_GANANCIA            NUMERIC(15,4),
    COEF_DESCUENTO           NUMERIC(15,4),
    IMPUESTO_INTERNO         NUMERIC(15,4),
    IMPUESTO_IVA             NUMERIC(15,4),
    PRECIO_COSTO_CIMPUESTOS  NUMERIC(15,4),
    IMPUESTO_ADICIONAL1      NUMERIC(15,4),
    IMPUESTO_ADICIONAL2      NUMERIC(15,4),
    PRECIO1                  FISCAL,
    PRECIO2                  FISCAL,
    PRECIO3                  FISCAL,
    PRECIO4                  FISCAL,
    PRECIO5                  FISCAL
);


CREATE TABLE PRODUCTO (
    ID_PRODUCTO              INTEGER NOT NULL,
    ID_MEDIDA                INTEGER,
    ID_PROD_CABECERA         INTEGER NOT NULL,
    DESCRIPCION              VARCHAR(500),
    PRECIO_COSTO             NUMERIC(15,4),
    PRECIO_VENTA             NUMERIC(15,4),
    COEF_GANANCIA            NUMERIC(15,4),
    COEF_DESCUENTO           NUMERIC(15,4),
    IMPUESTO_INTERNO         NUMERIC(15,4),
    IMPUESTO_IVA             NUMERIC(15,4),
    COD_CORTO                VARCHAR(20),
    CODIGO_BARRA             VARCHAR(40),
    STOCK_MAX                NUMERIC(15,4),
    STOCK_MIN                NUMERIC(15,4),
    LLEVAR_STOCK             VARCHAR(1),
    PRECIO_COSTO_CIMPUESTOS  NUMERIC(15,4),
    IMPUESTO_ADICIONAL1      NUMERIC(15,4),
    IMPUESTO_ADICIONAL2      NUMERIC(15,4),
    PRECIO1                  NUMERIC(15,4),
    PRECIO2                  NUMERIC(15,4),
    PRECIO3                  NUMERIC(15,4),
    PRECIO4                  NUMERIC(15,4),
    PRECIO5                  NUMERIC(15,4),
    BAJA                     VARCHAR(1) DEFAULT 'N'
);


CREATE TABLE PRODUCTO_CABECERA (
    ID_PROD_CABECERA  INTEGER NOT NULL,
    ID_MARCA          INTEGER NOT NULL,
    ID_ARTICULO       INTEGER NOT NULL,
    COLOR             INTEGER,
    COD_CORTO         VARCHAR(20),
    NOMBRE            VARCHAR(100),
    DESCRIPCION       VARCHAR(500),
    IMAGEN            BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    BAJA              VARCHAR(1)
);


CREATE TABLE PROVINCIA (
    ID_PROVINCIA      INTEGER NOT NULL,
    NOMBRE_PROVINCIA  VARCHAR(50)
);


CREATE TABLE STOCK_PRODUCTO (
    ID_STOCK_PRODUCTO     INTEGER NOT NULL,
    ID_PRODUCTO           INTEGER NOT NULL,
    ID_POSICION_SUCURSAL  INTEGER NOT NULL,
    STOCK_ACTUAL          NUMERIC(15,4),
    STOCK_MIN             NUMERIC(15,4),
    STOCK_MAX             NUMERIC(15,4),
    STOCK_REPEDIDO        NUMERIC(15,4),
    STOCK_MIN_ALARMA      VARCHAR(1)
);


CREATE TABLE SUCURSAL (
    ID_SUCURSAL           INTEGER NOT NULL,
    NOMBRE                VARCHAR(200),
    DIRECCION             VARCHAR(200),
    LOCALIDAD             VARCHAR(200),
    CODIGO_POSTAL         VARCHAR(20),
    TELEFONO              VARCHAR(100),
    EMAIL                 VARCHAR(100),
    BAJA                  VARCHAR(1),
    LOGO                  BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    REPORTE_TITULO        VARCHAR(50),
    REPORTE_SUBTITULO     VARCHAR(50),
    COMPROBANTE_TITULO    VARCHAR(50),
    COMPROBANTE_RENGLON1  VARCHAR(50),
    COMPROBANTE_RENGLON2  VARCHAR(50),
    COMPROBANTE_RENGLON3  VARCHAR(50),
    COMPROBANTE_RENGLON4  VARCHAR(50)
);


CREATE TABLE TEMP_PRODUCTO (
    ID_PRODUCTO  INTEGER
);


CREATE TABLE TEMP_SUCURSAL (
    ID_SUCURSAL  INTEGER
);


CREATE TABLE TIPO_ARTICULO (
    ID_TIPO_ARTICULO  INTEGER NOT NULL,
    DESCRIPCION       VARCHAR(200),
    BAJA              VARCHAR(1)
);


CREATE TABLE TIPO_COMPROBANTE (
    ID_TIPO_CPB       INTEGER NOT NULL,
    NOMBRE_TIPO_CPB   VARCHAR(50),
    SIGNO_COBRO_PAGO  INTEGER,
    SIGNO_STOCK       INTEGER,
    SIGNO_CTA_CTE     INTEGER,
    ULTIMO_NUMERO     INTEGER,
    BAJA              VARCHAR(1)
);


CREATE TABLE TIPO_DOCUMENTO (
    ID_TIPO_DOC      INTEGER NOT NULL,
    NOMBRE_TIPO_DOC  VARCHAR(20)
);


CREATE TABLE TIPO_EMPRESA (
    ID_TIPO_EMPRESA  INTEGER NOT NULL,
    DESCRIPCION      VARCHAR(100),
    BAJA             VARCHAR(1)
);


CREATE TABLE TIPO_FORMAPAGO (
    ID_TIPO_FORMAPAGO  INTEGER NOT NULL,
    DESCRIPCION        VARCHAR(50),
    BAJA               VARCHAR(1),
    "IF"               VARCHAR(1),
    DESC_REC           NUMERIC(15,2),
    COD_CORTO          INTEGER,
    GENERA_VUELTO      VARCHAR(1) DEFAULT 'N',
    COLUMNA_PRECIO     INTEGER,
    MODIFICABLE        VARCHAR(1)
);


CREATE TABLE TIPO_IVA (
    ID_TIPO_IVA      INTEGER NOT NULL,
    NOMBRE_TIPO_IVA  VARCHAR(50),
    ABREVIATURA      VARCHAR(10),
    DISCRIMINAR      VARCHAR(1),
    LETRA            VARCHAR(1),
    FISCAL           VARCHAR(1),
    COEFICIENTE      NUMERIC(10,4),
    VERIFICA_CUIT    VARCHAR(1)
);


CREATE TABLE TIPO_MOVIMIENTO (
    ID_TIPO_MOVIMIENTO  INTEGER NOT NULL,
    NOMBRE_MOVIMIENTO   VARCHAR(200),
    BAJA                VARCHAR(1)
);


CREATE TABLE TIPO_RELACION (
    ID_TIPO_RELACION  INTEGER NOT NULL,
    DESCRIPCION       VARCHAR(100)
);


INSERT INTO COLOR (ID_COLOR, CODIGO_COLOR, NOMBRE, REFERENCIA, BAJA) VALUES (0, 0, 'SIN COLOR', 'clSilver', 'N');

COMMIT WORK;

INSERT INTO COMPROBANTE_ESTADO (ID_COMP_ESTADO, DESCRIPCION) VALUES (0, 'SIN CONFIRMAR');
INSERT INTO COMPROBANTE_ESTADO (ID_COMP_ESTADO, DESCRIPCION) VALUES (1, 'CONFIRMADO');
INSERT INTO COMPROBANTE_ESTADO (ID_COMP_ESTADO, DESCRIPCION) VALUES (2, 'ALMACENADO');
INSERT INTO COMPROBANTE_ESTADO (ID_COMP_ESTADO, DESCRIPCION) VALUES (3, 'ANULADO');

COMMIT WORK;

INSERT INTO CONFIGURACION (DB_SUCURSAL, ID_SUCURSAL, ULTIMA_FECHA) VALUES (11, 11, NULL);

COMMIT WORK;

INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('colorCampoRequido', NULL, NULL, '$00B3FFFF', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('TextoPieDePagina', NULL, NULL, 'Sistema Gestin y Facturacin - ', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('provinciaPorDefecto', NULL, 1, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('imp_ad1_nombre', NULL, NULL, 'Per. IB', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('imp_ad2_nombre', NULL, NULL, 'Res. 3337', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('PRECIO1', NULL, NULL, 'Efectivo', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('PRECIO2', NULL, NULL, 'Tarjeta', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('PRECIO3', NULL, NULL, 'Cheque', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('PRECIO4', NULL, NULL, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('PRECIO5', NULL, NULL, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('MONTO_MAX_VENTA', NULL, 15000, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('ctacte_diasVencimiento', NULL, 15, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('ctacte_credito', NULL, 5000, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('confirmarNotaPedido', NULL, NULL, 'SI', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('cuenta_defecto', NULL, 112, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('notaCredito_diasVencimiento', NULL, 20, '', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('horaAperturaNegocio', NULL, NULL, '08:00:00', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('horaCierreNegocio', NULL, NULL, '21:00:00', NULL, NULL, NULL);
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('tipo_reporte_etiquetas', NULL, 1, '', NULL, NULL, 'Tipo de reporte del imprimir etiquetas (1: 3 etiq x fila, 2: 4 etiq x fila)');
INSERT INTO CONFIGURACION_VARIABLES (CLAVE, FECHA, NUMERO, TEXTO, NIVEL, GRUPO, DESCRIPCION) VALUES ('demoSistema', NULL, NULL, 'NO', NULL, NULL, 'En SI me indica que el sistema es una demo que caduca en la FECHA especificada');

COMMIT WORK;

INSERT INTO SUCURSAL (ID_SUCURSAL, NOMBRE, DIRECCION, LOCALIDAD, CODIGO_POSTAL, TELEFONO, EMAIL, BAJA, REPORTE_TITULO, REPORTE_SUBTITULO, COMPROBANTE_TITULO, COMPROBANTE_RENGLON1, COMPROBANTE_RENGLON2, COMPROBANTE_RENGLON3, COMPROBANTE_RENGLON4) VALUES (0, 'ADMINISTRADOR', NULL, NULL, NULL, NULL, NULL, 'N', 'SIGEFA', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO SUCURSAL (ID_SUCURSAL, NOMBRE, DIRECCION, LOCALIDAD, CODIGO_POSTAL, TELEFONO, EMAIL, BAJA, REPORTE_TITULO, REPORTE_SUBTITULO, COMPROBANTE_TITULO, COMPROBANTE_RENGLON1, COMPROBANTE_RENGLON2, COMPROBANTE_RENGLON3, COMPROBANTE_RENGLON4) VALUES (11, 'CASA CENTRAL', NULL, NULL, NULL, NULL, NULL, 'N', 'SIGEFA', NULL, NULL, NULL, NULL, NULL, NULL);

COMMIT WORK;

INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (11, 'EFECTIVO F', 'N', 'S', NULL, NULL, 'S', 1, 'S');
INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (12, 'CHEQUE', 'N', 'S', NULL, NULL, 'N', 3, 'S');
INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (14, 'EFECTIVO', 'N', 'N', NULL, NULL, 'S', 1, 'S');
INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (13, 'TARJETA', 'N', 'S', NULL, NULL, 'N', 2, 'S');
INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (1, 'CUENTA CORRIENTE', 'N', 'N', NULL, NULL, 'N', NULL, 'N');
INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (2, 'NOTA CREDITO', 'N', 'N', NULL, NULL, 'N', NULL, 'N');
INSERT INTO TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO, DESCRIPCION, BAJA, "IF", DESC_REC, COD_CORTO, GENERA_VUELTO, COLUMNA_PRECIO, MODIFICABLE) VALUES (3, 'TRANSFERENCIA', 'N', 'N', NULL, NULL, 'N', NULL, 'N');

COMMIT WORK;

INSERT INTO CUENTA (ID_CUENTA, MEDIO_DEFECTO, CODIGO, NOMBRE_CUENTA, NRO_CTA_BANCARIA, BAJA, ID_SUCURSAL, A_CTA_CORRIENTE, A_NOTA_CREDITO, MODIFICABLE) VALUES (1, 1, NULL, 'CUENTA CORRIENTE', NULL, 'N', 0, 'S', 'N', 'N');
INSERT INTO CUENTA (ID_CUENTA, MEDIO_DEFECTO, CODIGO, NOMBRE_CUENTA, NRO_CTA_BANCARIA, BAJA, ID_SUCURSAL, A_CTA_CORRIENTE, A_NOTA_CREDITO, MODIFICABLE) VALUES (2, 2, NULL, 'NOTA CREDITO', NULL, 'N', 0, 'N', 'S', 'N');

COMMIT WORK;

INSERT INTO MARCA (ID_MARCA, CODIGO_MARCA, NOMBRE_MARCA, BAJA) VALUES (0, 0, 'SIN MARCA', 'N');

COMMIT WORK;

INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (1, 'SANTA FE');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (2, 'BUENOS AIRES');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (4, 'CORRIENTES');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (6, 'STGO. DEL ESTERO');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (7, 'CORDOBA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (8, 'LA PAMPA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (0, 'NINGUNA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (9, 'CHUBUT');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (10, 'FORMOSA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (11, 'MENDOZA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (12, 'MISIONES');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (13, 'NEUQUEN');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (14, 'RIO NEGRO');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (15, 'SALTA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (16, 'SAN JUAN');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (17, 'SANTA CRUZ');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (18, 'TUCUMAN');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (3, 'ENTRE RIOS');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (5, 'CHACO');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (19, 'CATAMARCA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (20, 'JUJUY');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (21, 'LA RIOJA');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (22, 'SAN LUIS');
INSERT INTO PROVINCIA (ID_PROVINCIA, NOMBRE_PROVINCIA) VALUES (23, 'TIERRA DEL FUEGO');

COMMIT WORK;

INSERT INTO TIPO_DOCUMENTO (ID_TIPO_DOC, NOMBRE_TIPO_DOC) VALUES (0, 'NINGUNO');
INSERT INTO TIPO_DOCUMENTO (ID_TIPO_DOC, NOMBRE_TIPO_DOC) VALUES (11, 'DNI');
INSERT INTO TIPO_DOCUMENTO (ID_TIPO_DOC, NOMBRE_TIPO_DOC) VALUES (12, 'L.C.');
INSERT INTO TIPO_DOCUMENTO (ID_TIPO_DOC, NOMBRE_TIPO_DOC) VALUES (13, 'L.E.');
INSERT INTO TIPO_DOCUMENTO (ID_TIPO_DOC, NOMBRE_TIPO_DOC) VALUES (14, 'C.I.');
INSERT INTO TIPO_DOCUMENTO (ID_TIPO_DOC, NOMBRE_TIPO_DOC) VALUES (15, 'PASAPORTE');

COMMIT WORK;

INSERT INTO TIPO_IVA (ID_TIPO_IVA, NOMBRE_TIPO_IVA, ABREVIATURA, DISCRIMINAR, LETRA, FISCAL, COEFICIENTE, VERIFICA_CUIT) VALUES (11, 'CONSUMIDOR FINAL', 'CF', 'N', 'B', 'F', 0.21, 'N');
INSERT INTO TIPO_IVA (ID_TIPO_IVA, NOMBRE_TIPO_IVA, ABREVIATURA, DISCRIMINAR, LETRA, FISCAL, COEFICIENTE, VERIFICA_CUIT) VALUES (12, 'RESPONSABLE INSCRIPTO', 'RI', 'S', 'A', 'I', 0.21, 'S');
INSERT INTO TIPO_IVA (ID_TIPO_IVA, NOMBRE_TIPO_IVA, ABREVIATURA, DISCRIMINAR, LETRA, FISCAL, COEFICIENTE, VERIFICA_CUIT) VALUES (13, 'RESPONSABLE NO INSCRIPTO', 'RNI', 'S', 'A', 'N', 0.21, 'S');
INSERT INTO TIPO_IVA (ID_TIPO_IVA, NOMBRE_TIPO_IVA, ABREVIATURA, DISCRIMINAR, LETRA, FISCAL, COEFICIENTE, VERIFICA_CUIT) VALUES (14, 'MONOTRIBUTO', 'MT', 'N', 'B', 'M', 0.21, 'N');
INSERT INTO TIPO_IVA (ID_TIPO_IVA, NOMBRE_TIPO_IVA, ABREVIATURA, DISCRIMINAR, LETRA, FISCAL, COEFICIENTE, VERIFICA_CUIT) VALUES (15, 'EXENTO', 'EX', 'N', 'B', 'E', 0, 'S');

COMMIT WORK;

INSERT INTO PERSONA (ID_PERSONA, ID_PROVINCIA, ID_TIPO_DOC, ID_TIPO_IVA, NOMBRE, DIRECCION, LOCALIDAD, CODIGO_POSTAL, TELEFONO, EMAIL, FECHA_NACIMIENTO, NUMERO_DOC, SEXO, BAJA, DESCRIPCION, CUIT_CUIL, DESCUENTO_ESPECIAL, CODIGO_CORTO, CODIGO_BARRA) VALUES (0, NULL, NULL, 11, 'CONSUMIDOR FINAL', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'N', 'CONSUMIDOR FINAL', NULL, NULL, 0, NULL);

COMMIT WORK;

INSERT INTO TIPO_RELACION (ID_TIPO_RELACION, DESCRIPCION) VALUES (11, 'CLIENTE');
INSERT INTO TIPO_RELACION (ID_TIPO_RELACION, DESCRIPCION) VALUES (12, 'EMPLEADO');
INSERT INTO TIPO_RELACION (ID_TIPO_RELACION, DESCRIPCION) VALUES (13, 'VIAJANTE');
INSERT INTO TIPO_RELACION (ID_TIPO_RELACION, DESCRIPCION) VALUES (14, 'CONTACTO');

COMMIT WORK;

INSERT INTO PERSONA_RELACION (ID_PERSONA_RELACION, ID_PERSONA, ID_RELACION, ID_EMPRESA, ID_SUCURSAL) VALUES (111, 0, 11, NULL, 11);

COMMIT WORK;

INSERT INTO POSICION_SUCURSAL (ID_POSICION_SUCURSAL, ID_SUCURSAL, SECCION, SECTOR, FILA, COLUMNA, BAJA, PUNTO_SALIDA) VALUES (111, 11, 'VENTA', NULL, NULL, NULL, 'N', 'S');

COMMIT WORK;

INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (14, 'PRESUPUESTO', 0, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (15, 'NOTA PEDIDO', 0, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (11, 'FACTURA', 1, -1, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (12, 'DEVOLUCION', -1, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (16, 'OTROS INGRESOS', 1, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (17, 'OTROS EGRESOS', -1, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (10, 'PREVENTA', 0, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (21, 'TRANSFERENCIA', 1, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (22, 'RECIBO CTA. CTE.', 0, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (23, 'ORDEN PAGO CTA. CTE.', 0, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (13, 'FACTURA COMPRA', -1, 1, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (18, 'ORDEN DE PAGO', -1, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (19, 'RECIBO DE COBRO', 1, 0, 0, 0, 'N');
INSERT INTO TIPO_COMPROBANTE (ID_TIPO_CPB, NOMBRE_TIPO_CPB, SIGNO_COBRO_PAGO, SIGNO_STOCK, SIGNO_CTA_CTE, ULTIMO_NUMERO, BAJA) VALUES (20, 'REMITO DE VENTA', 0, 0, 0, 0, 'N');

COMMIT WORK;



/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE MARCA ADD CONSTRAINT UNQ1_MARCA UNIQUE (CODIGO_MARCA);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ARTICULO ADD CONSTRAINT "Articulo PK" PRIMARY KEY (ID_ARTICULO);
ALTER TABLE CAJA_NRO ADD CONSTRAINT PK_CAJA_NRO PRIMARY KEY (ID_CAJA);
ALTER TABLE COLOR ADD CONSTRAINT PK_COLOR_1 PRIMARY KEY (ID_COLOR);
ALTER TABLE COMPROBANTE ADD CONSTRAINT PK_FACTURA PRIMARY KEY (ID_COMPROBANTE);
ALTER TABLE COMPROBANTE_DETALLE ADD CONSTRAINT PK_DETALLE_FACTURA PRIMARY KEY (ID_COMPROBANTE_DETALLE);
ALTER TABLE COMPROBANTE_ESTADO ADD CONSTRAINT PK_COMPROBANTE_ESTADO PRIMARY KEY (ID_COMP_ESTADO);
ALTER TABLE COMPROBANTE_FORMA_PAGO ADD CONSTRAINT PK_COMPROBANTE_FORMA_PAGO PRIMARY KEY (ID_COMPROB_FP);
ALTER TABLE CUENTA ADD CONSTRAINT PK_CUENTA PRIMARY KEY (ID_CUENTA);
ALTER TABLE CUENTA_CORRIENTE ADD CONSTRAINT PK_CUENTA_CORRIENTE PRIMARY KEY (ID_CTA_CTE);
ALTER TABLE EMPRESA ADD CONSTRAINT "Empresa PK" PRIMARY KEY (ID_EMPRESA);
ALTER TABLE EMPRESA_MARCA ADD CONSTRAINT "Empresa_Marka PK" PRIMARY KEY (ID);
ALTER TABLE ENTIDAD_TELEFONOS ADD CONSTRAINT PK_ENTIDAD_TELEFONOS PRIMARY KEY (ID_ENTIDAD_TELEFONO);
ALTER TABLE MAIL_ADJUNTOS ADD CONSTRAINT PK_MAIL_ADJUNTOS PRIMARY KEY (ID_ADJUNTO);
ALTER TABLE MAIL_CUENTAS ADD CONSTRAINT PK_MAIL_CUENTAS PRIMARY KEY (ID_CUENTA);
ALTER TABLE MAIL_MENSAJE ADD CONSTRAINT PK_MAIL_MENSAJE PRIMARY KEY (ID_MAIL_MENSAJE);
ALTER TABLE MARCA ADD CONSTRAINT "Marca PK" PRIMARY KEY (ID_MARCA);
ALTER TABLE MEDIDA ADD CONSTRAINT "Medida PK" PRIMARY KEY (ID_MEDIDA);
ALTER TABLE MEDIDA_ARTICULO ADD PRIMARY KEY (ID_MEDIDA_ARTICULO);
ALTER TABLE PAGO_FACTURAS ADD CONSTRAINT PK_PAGO_FACTURAS PRIMARY KEY (ID_PAGO_FACTURAS);
ALTER TABLE PERSONA ADD CONSTRAINT "Persona PK" PRIMARY KEY (ID_PERSONA);
ALTER TABLE PERSONA_PUNTOS ADD CONSTRAINT PK_PERSONA_PUNTOS PRIMARY KEY (ID_PERSONA_PUNTO);
ALTER TABLE PERSONA_RELACION ADD CONSTRAINT "Persona_Relacion PK" PRIMARY KEY (ID_PERSONA_RELACION);
ALTER TABLE POSICION_SUCURSAL ADD CONSTRAINT "Posicion_Sucursal PK" PRIMARY KEY (ID_POSICION_SUCURSAL);
ALTER TABLE PRECIO ADD CONSTRAINT PK_PRECIO PRIMARY KEY (ID_PRECIO);
ALTER TABLE PRODUCTO ADD CONSTRAINT "Producto PK" PRIMARY KEY (ID_PRODUCTO);
ALTER TABLE PRODUCTO_CABECERA ADD CONSTRAINT "Producto_Cabecera PK" PRIMARY KEY (ID_PROD_CABECERA);
ALTER TABLE PROVINCIA ADD CONSTRAINT "Provincia PK" PRIMARY KEY (ID_PROVINCIA);
ALTER TABLE STOCK_PRODUCTO ADD PRIMARY KEY (ID_STOCK_PRODUCTO);
ALTER TABLE SUCURSAL ADD CONSTRAINT "Sucursal PK" PRIMARY KEY (ID_SUCURSAL);
ALTER TABLE TIPO_ARTICULO ADD CONSTRAINT "Tipo_Articulo PK" PRIMARY KEY (ID_TIPO_ARTICULO);
ALTER TABLE TIPO_COMPROBANTE ADD CONSTRAINT "Tipo_Comprobante PK" PRIMARY KEY (ID_TIPO_CPB);
ALTER TABLE TIPO_DOCUMENTO ADD CONSTRAINT "Tipo_Documento PK" PRIMARY KEY (ID_TIPO_DOC);
ALTER TABLE TIPO_EMPRESA ADD CONSTRAINT "Tipo_Empresa PK" PRIMARY KEY (ID_TIPO_EMPRESA);
ALTER TABLE TIPO_FORMAPAGO ADD CONSTRAINT PK_FORMA_DE_PAGO PRIMARY KEY (ID_TIPO_FORMAPAGO);
ALTER TABLE TIPO_IVA ADD CONSTRAINT "Tipo_Iva PK" PRIMARY KEY (ID_TIPO_IVA);
ALTER TABLE TIPO_MOVIMIENTO ADD CONSTRAINT PK_TIPO_MOVIMIENTO PRIMARY KEY (ID_TIPO_MOVIMIENTO);
ALTER TABLE TIPO_RELACION ADD CONSTRAINT "Tipo_Relacion PK" PRIMARY KEY (ID_TIPO_RELACION);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE ARTICULO ADD CONSTRAINT "Articulo FK_1" FOREIGN KEY (ID_TIPO_ARTICULO) REFERENCES TIPO_ARTICULO (ID_TIPO_ARTICULO);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_1 FOREIGN KEY (ID_PROVEEDOR) REFERENCES EMPRESA (ID_EMPRESA);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_2 FOREIGN KEY (ID_SUCURSAL) REFERENCES SUCURSAL (ID_SUCURSAL);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_3 FOREIGN KEY (ID_VENDEDOR) REFERENCES PERSONA (ID_PERSONA);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_4 FOREIGN KEY (ID_CLIENTE) REFERENCES PERSONA (ID_PERSONA);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_5 FOREIGN KEY (ID_TIPO_CPB) REFERENCES TIPO_COMPROBANTE (ID_TIPO_CPB);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_6 FOREIGN KEY (ID_TIPO_MOVIMIENTO) REFERENCES TIPO_MOVIMIENTO (ID_TIPO_MOVIMIENTO);
ALTER TABLE COMPROBANTE ADD CONSTRAINT FK_COMPROBANTE_7 FOREIGN KEY (ID_TIPO_IVA) REFERENCES TIPO_IVA (ID_TIPO_IVA);
ALTER TABLE COMPROBANTE_DETALLE ADD CONSTRAINT FK_COMPROBANTE_DETALLE_2 FOREIGN KEY (ID_PRODUCTO) REFERENCES PRODUCTO (ID_PRODUCTO);
ALTER TABLE COMPROBANTE_FORMA_PAGO ADD CONSTRAINT FK_COMPROBANTE_FORMA_PAGO_2 FOREIGN KEY (ID_TIPO_FORMAPAG) REFERENCES TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO);
ALTER TABLE CUENTA ADD CONSTRAINT FK_CUENTA_1 FOREIGN KEY (MEDIO_DEFECTO) REFERENCES TIPO_FORMAPAGO (ID_TIPO_FORMAPAGO);
ALTER TABLE CUENTA ADD CONSTRAINT FK_CUENTA_2 FOREIGN KEY (ID_SUCURSAL) REFERENCES SUCURSAL (ID_SUCURSAL);
ALTER TABLE CUENTA_CORRIENTE ADD CONSTRAINT FK_CUENTA_CORRIENTE_1 FOREIGN KEY (ID_PERSONA) REFERENCES PERSONA (ID_PERSONA);
ALTER TABLE EMPRESA ADD CONSTRAINT "Empresa FK_1" FOREIGN KEY (ID_PROVINCIA) REFERENCES PROVINCIA (ID_PROVINCIA);
ALTER TABLE EMPRESA ADD CONSTRAINT "Empresa FK_2" FOREIGN KEY (ID_TIPO_IVA) REFERENCES TIPO_IVA (ID_TIPO_IVA);
ALTER TABLE EMPRESA ADD CONSTRAINT "Empresa FK_3" FOREIGN KEY (ID_TIPO_EMPRESA) REFERENCES TIPO_EMPRESA (ID_TIPO_EMPRESA);
ALTER TABLE EMPRESA_MARCA ADD CONSTRAINT "Empresa_Marca FK_1" FOREIGN KEY (ID_EMPRESA) REFERENCES EMPRESA (ID_EMPRESA);
ALTER TABLE EMPRESA_MARCA ADD CONSTRAINT "Empresa_Marca FK_2" FOREIGN KEY (ID_MARCA) REFERENCES MARCA (ID_MARCA);
ALTER TABLE MAIL_ADJUNTOS ADD CONSTRAINT FK_MAIL_ADJUNTOS_1 FOREIGN KEY (ID_MAIL) REFERENCES MAIL_MENSAJE (ID_MAIL_MENSAJE);
ALTER TABLE MAIL_CUENTAS ADD CONSTRAINT FK_MAIL_CUENTAS_1 FOREIGN KEY (ID_SUCURSAL) REFERENCES SUCURSAL (ID_SUCURSAL);
ALTER TABLE MAIL_MENSAJE ADD CONSTRAINT FK_MAIL_MENSAJE_1 FOREIGN KEY (ID_CUENTA) REFERENCES MAIL_CUENTAS (ID_CUENTA);
ALTER TABLE MEDIDA_ARTICULO ADD CONSTRAINT "Medida_Articulo FK_1" FOREIGN KEY (ID_ARTICULO) REFERENCES ARTICULO (ID_ARTICULO);
ALTER TABLE MEDIDA_ARTICULO ADD CONSTRAINT "Medida_Articulo FK_2" FOREIGN KEY (ID_MEDIDA) REFERENCES MEDIDA (ID_MEDIDA);
ALTER TABLE PAGO_FACTURAS ADD CONSTRAINT FK_PAGO_FACTURAS_1 FOREIGN KEY (ID_COMPROBANTE) REFERENCES COMPROBANTE (ID_COMPROBANTE);
ALTER TABLE PAGO_FACTURAS ADD CONSTRAINT FK_PAGO_FACTURAS_2 FOREIGN KEY (ID_FACTURA) REFERENCES COMPROBANTE (ID_COMPROBANTE);
ALTER TABLE PAGO_FACTURAS ADD CONSTRAINT FK_PAGO_FACTURAS_3 FOREIGN KEY (ID_TIPO_COMPROBANTE) REFERENCES TIPO_COMPROBANTE (ID_TIPO_CPB);
ALTER TABLE PERSONA ADD CONSTRAINT "Persona FK_1" FOREIGN KEY (ID_PROVINCIA) REFERENCES PROVINCIA (ID_PROVINCIA);
ALTER TABLE PERSONA ADD CONSTRAINT "Persona FK_2" FOREIGN KEY (ID_TIPO_DOC) REFERENCES TIPO_DOCUMENTO (ID_TIPO_DOC);
ALTER TABLE PERSONA ADD CONSTRAINT "Persona FK_3" FOREIGN KEY (ID_TIPO_IVA) REFERENCES TIPO_IVA (ID_TIPO_IVA);
ALTER TABLE PERSONA_RELACION ADD CONSTRAINT "Persona_Relacion FK_1" FOREIGN KEY (ID_PERSONA) REFERENCES PERSONA (ID_PERSONA);
ALTER TABLE PERSONA_RELACION ADD CONSTRAINT "Persona_Relacion FK_2" FOREIGN KEY (ID_RELACION) REFERENCES TIPO_RELACION (ID_TIPO_RELACION);
ALTER TABLE PERSONA_RELACION ADD CONSTRAINT "Persona_Relacion FK_3" FOREIGN KEY (ID_EMPRESA) REFERENCES EMPRESA (ID_EMPRESA);
ALTER TABLE PERSONA_RELACION ADD CONSTRAINT "Persona_Relacion FK_4" FOREIGN KEY (ID_SUCURSAL) REFERENCES SUCURSAL (ID_SUCURSAL);
ALTER TABLE POSICION_SUCURSAL ADD CONSTRAINT "Posicion_Producto FK_3" FOREIGN KEY (ID_SUCURSAL) REFERENCES SUCURSAL (ID_SUCURSAL);
ALTER TABLE PRECIO ADD CONSTRAINT FK_PRECIO_1 FOREIGN KEY (ID_PRODUCTO) REFERENCES PRODUCTO (ID_PRODUCTO);
ALTER TABLE PRECIO ADD CONSTRAINT FK_PRECIO_2 FOREIGN KEY (ID_SUCURSAL) REFERENCES SUCURSAL (ID_SUCURSAL);
ALTER TABLE PRODUCTO ADD CONSTRAINT "Producto FK_1" FOREIGN KEY (ID_MEDIDA) REFERENCES MEDIDA (ID_MEDIDA);
ALTER TABLE PRODUCTO_CABECERA ADD CONSTRAINT "Producto_Cabecera FK_1" FOREIGN KEY (ID_MARCA) REFERENCES MARCA (ID_MARCA);
ALTER TABLE PRODUCTO_CABECERA ADD CONSTRAINT "Producto_Cabecera FK_2" FOREIGN KEY (ID_ARTICULO) REFERENCES ARTICULO (ID_ARTICULO);
ALTER TABLE STOCK_PRODUCTO ADD CONSTRAINT FK_STOCK_PRODUCTO_1 FOREIGN KEY (ID_POSICION_SUCURSAL) REFERENCES POSICION_SUCURSAL (ID_POSICION_SUCURSAL);
ALTER TABLE STOCK_PRODUCTO ADD CONSTRAINT FK_STOCK_PRODUCTO_2 FOREIGN KEY (ID_PRODUCTO) REFERENCES PRODUCTO (ID_PRODUCTO);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX COMPROBANTE_DETALLE_IDX1 ON COMPROBANTE_DETALLE (ID_COMPROBANTE);
CREATE INDEX COMPROBANTE_FORMA_PAGO_IDX1 ON COMPROBANTE_FORMA_PAGO (ID_COMPROBANTE);
CREATE INDEX CONFIGURACION_IDX1 ON CONFIGURACION (ID_SUCURSAL);
CREATE INDEX CONFIGURACION_VARIABLES_IDX1 ON CONFIGURACION_VARIABLES (CLAVE);
CREATE INDEX EMPRESA__IDX1 ON EMPRESA (ID_PROVINCIA);
CREATE INDEX EMPRESA__IDX2 ON EMPRESA (CUIT_CUIL);
CREATE INDEX EMPRESA__IDX3 ON EMPRESA (ID_TIPO_IVA);
CREATE INDEX PERSONA_IDX1 ON PERSONA (NOMBRE);
CREATE INDEX PERSONA__IDX1 ON PERSONA (ID_PROVINCIA);
CREATE INDEX PERSONA__IDX2 ON PERSONA (ID_TIPO_DOC);
CREATE INDEX POSICION_SUCURSAL_IDX1 ON POSICION_SUCURSAL (SECCION, ID_POSICION_SUCURSAL);
CREATE INDEX PRODUCTO_IDX1 ON PRODUCTO (ID_PROD_CABECERA);
CREATE INDEX PRODUCTO_IDX2 ON PRODUCTO (COD_CORTO);
CREATE INDEX PRODUCTO_IDX3 ON PRODUCTO (CODIGO_BARRA);
CREATE INDEX PRODUCTO__IDX1 ON PRODUCTO (ID_MEDIDA);
CREATE INDEX STOCK_PRODUCTO_IDX1 ON STOCK_PRODUCTO (ID_PRODUCTO, ID_POSICION_SUCURSAL, STOCK_ACTUAL);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: ARTICULO_BI */
CREATE TRIGGER ARTICULO_BI FOR ARTICULO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(GEN_ARTICULO_ID,1);

  IF (NEW.ID_ARTICULO IS NULL) THEN
    NEW.ID_ARTICULO = clave;

  new.baja = 'N';
END
^


/* Trigger: CAJA_NRO_BI */
CREATE TRIGGER CAJA_NRO_BI FOR CAJA_NRO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_caja_nro_id,1);

  IF (NEW.id_caja IS NULL) THEN
    NEW.id_caja = clave;
END
^


/* Trigger: COLOR_BI */
CREATE TRIGGER COLOR_BI FOR COLOR
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_color_id,1);

  IF (NEW.ID_COLOR IS NULL) THEN
    NEW.ID_COLOR = clave;
END
^


/* Trigger: COMPROBANTE_BI0 */
CREATE TRIGGER COMPROBANTE_BI0 FOR COMPROBANTE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.codigo is null) then
    new.codigo = lpad(new.id_comprobante, 10, '0');
end
^


/* Trigger: COMPROBANTE_CTACTE_SALDO */
CREATE TRIGGER COMPROBANTE_CTACTE_SALDO FOR COMPROBANTE
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
as
begin
  if ((new.id_tipo_cpb = 11) or (new.id_tipo_cpb = 16) or (new.id_tipo_cpb = 17)) then
  begin
    if (inserting) then --si es un insert
    begin
      update cuenta_corriente cc --resto el saldo anterior y le sumo el nuevo
      set cc.saldo = cc.saldo + new.saldo
      where cc.id_persona = new.id_cliente;
    end

    if (updating) then --si es un update
    begin
      update cuenta_corriente cc --resto el saldo anterior y le sumo el nuevo
      set cc.saldo = cc.saldo - old.saldo + new.saldo
      where cc.id_persona = new.id_cliente;
    end

    if (deleting) then --si es un delete
    begin
      update cuenta_corriente cc --resto el saldo anterior y le sumo el nuevo
      set cc.saldo = cc.saldo - old.saldo
      where cc.id_persona = old.id_cliente;
    end
  end

  if ((new.id_tipo_cpb = 11)and(inserting)) then
  begin
    execute procedure acumular_persona_puntos(new.id_cliente,new.importe_venta);
  end
end
^


/* Trigger: COMPROBANTE_DETALLE_AIU0 */
CREATE TRIGGER COMPROBANTE_DETALLE_AIU0 FOR COMPROBANTE_DETALLE
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
declare variable id integer;
declare variable id_tipo_cpb integer;
begin
  id = null;
  /* Descuento del Stock correspondiente */
  if (inserting) then
  begin
    select c.id_tipo_cpb
    from comprobante c
    where c.id_comprobante = new.id_comprobante
    into :id_tipo_cpb;

    if ((id_tipo_cpb is not null) and (:id_tipo_cpb = 11)) then --si es una factura de venta
    begin
      select first 1 sp.id_stock_producto --obtengo el id_stock de la posicion seleccinada como punta salida
      from stock_producto sp
      join posicion_sucursal ps on (ps.id_posicion_sucursal = sp.id_posicion_sucursal)
      where (sp.id_producto = new.id_producto)
        and (ps.punto_salida = 'S')
      into :id;

      if ((id is not null) and (new.cantidad > 0)) then --si existe ese producto en la posicion y la cantidad es mayor a 0
        execute procedure procesar_stock(:id, new.id_producto, null, new.cantidad, null, null, null, new.id_comprobante);
    end
  end
end
^


/* Trigger: COMPROBANTE_DETALLE_BI */
CREATE TRIGGER COMPROBANTE_DETALLE_BI FOR COMPROBANTE_DETALLE
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_comprobante_detalle_id,1);

  IF (NEW.id_comprobante_detalle IS NULL) THEN
    NEW.id_comprobante_detalle = clave;
END
^


/* Trigger: COMPROBANTE_ESTADO_BI */
CREATE TRIGGER COMPROBANTE_ESTADO_BI FOR COMPROBANTE_ESTADO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_comprobante_estado_id,1);

  IF (NEW.ID_COMP_ESTADO IS NULL) THEN
    NEW.ID_COMP_ESTADO = clave;
END
^


/* Trigger: COMPROBANTE_FORMA_PAGO_BI */
CREATE TRIGGER COMPROBANTE_FORMA_PAGO_BI FOR COMPROBANTE_FORMA_PAGO
ACTIVE BEFORE INSERT POSITION 0
as
declare variable id_sucursal integer;
declare variable clave varchar(30);
begin
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
    exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal || gen_id(gen_comprobante_forma_pago_id, 1);

  if (new.id_comprob_fp is null) then
    new.id_comprob_fp = clave;
end
^


/* Trigger: COMPROBANTE_FPAGO_CALC_SALDO */
CREATE TRIGGER COMPROBANTE_FPAGO_CALC_SALDO FOR COMPROBANTE_FORMA_PAGO
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
as
declare variable tipo_comprobante integer;
declare variable importe_comprobante numeric(15,4);
declare variable importe_cancelado numeric(15,4);
declare variable importe_cta_cte numeric(15,4);
declare variable saldo_comprobante numeric(15,4);
declare variable id integer;
begin
  importe_comprobante = null;
  tipo_comprobante = null;

  if ((inserting) or (updating)) then
    id = new.id_comprobante;
  else
  if (deleting) then
    id = old.id_comprobante;

  --obtengo el tipo de comprobante y el monto final del mismo
  select c.id_tipo_cpb, c.importe_venta
  from comprobante c
  where c.id_comprobante = :id
  into :tipo_comprobante, :importe_comprobante;

  if (((:tipo_comprobante = 11) or (:tipo_comprobante = 13)) and (importe_comprobante is not null)) then --si es una factura
  begin --y tiene cargado el importe de venta

    select sum(cfp.importe_real) --sumo el importe de todas las formas de pago asociadas
    from comprobante_forma_pago cfp --a la factura que no sean cuanta corriente
    where cfp.id_comprobante = :id
      and cfp.id_tipo_formapag > 2
    into :importe_cancelado;

    select sum(cfp.importe_real) --sumo el importe de todas las formas de pago asociadas
    from comprobante_forma_pago cfp --a la factura que sean cuanta corriente
    where cfp.id_comprobante = :id
      and cfp.id_tipo_formapag = 1
    into :importe_cta_cte;

    if (:importe_cancelado is not null) then
      saldo_comprobante = importe_comprobante - importe_cancelado;
    else
      saldo_comprobante = importe_comprobante;

    update comprobante cpb
    set cpb.saldo = :saldo_comprobante
    where (cpb.id_comprobante = :id);
  end
end
^


/* Trigger: CUENTA_BI */
CREATE TRIGGER CUENTA_BI FOR CUENTA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_cuenta_id,1);

  IF (NEW.ID_CUENTA IS NULL) THEN
    NEW.ID_CUENTA = clave;
END
^


/* Trigger: CUENTA_CORRIENTE_BI */
CREATE TRIGGER CUENTA_CORRIENTE_BI FOR CUENTA_CORRIENTE
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(GEN_CUENTA_CORRIENTE_ID,1);

  IF (NEW.ID_CTA_CTE IS NULL) THEN
    NEW.ID_CTA_CTE = clave;
END
^


/* Trigger: EMPRESA_BI */
CREATE TRIGGER EMPRESA_BI FOR EMPRESA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_empresa_id,1);

  IF (NEW.ID_EMPRESA IS NULL) THEN
    NEW.ID_EMPRESA = clave;
END
^


/* Trigger: EMPRESA_MARCA_BI */
CREATE TRIGGER EMPRESA_MARCA_BI FOR EMPRESA_MARCA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_empresa_marca_id,1);

  IF (NEW.ID IS NULL) THEN
    NEW.ID = clave;
END
^


/* Trigger: ENTIDAD_TELEFONOS_BI */
CREATE TRIGGER ENTIDAD_TELEFONOS_BI FOR ENTIDAD_TELEFONOS
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(GEN_ENTIDAD_TELEFONOS_ID,1);

  IF (NEW.ID_ENTIDAD_TELEFONO IS NULL) THEN
    NEW.ID_ENTIDAD_TELEFONO = clave;
END
^


/* Trigger: MAIL_ADJUNTOS_BI */
CREATE TRIGGER MAIL_ADJUNTOS_BI FOR MAIL_ADJUNTOS
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_mail_adjuntos_id,1);

  IF (NEW.ID_ADJUNTO IS NULL) THEN
    NEW.ID_ADJUNTO = clave;
END
^


/* Trigger: MAIL_CUENTAS_BI */
CREATE TRIGGER MAIL_CUENTAS_BI FOR MAIL_CUENTAS
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_mail_cuentas_id,1);

  IF (NEW.ID_CUENTA IS NULL) THEN
    NEW.ID_CUENTA = clave;
END
^


/* Trigger: MAIL_MENSAJE_BI */
CREATE TRIGGER MAIL_MENSAJE_BI FOR MAIL_MENSAJE
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_mail_mensaje_id,1);

  IF (NEW.ID_MAIL_MENSAJE IS NULL) THEN
    NEW.ID_MAIL_MENSAJE = clave;

  new.fecha_y_hora = current_timestamp;
END
^


/* Trigger: MARCA_BI */
CREATE TRIGGER MARCA_BI FOR MARCA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_marca_id,1);

  IF (NEW.ID_MARCA IS NULL) THEN
    NEW.ID_MARCA = clave;

  new.baja = 'N';
END
^


/* Trigger: MEDIDA_ARTICULO_BI */
CREATE TRIGGER MEDIDA_ARTICULO_BI FOR MEDIDA_ARTICULO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_medida_articulo_id,1);

  IF (NEW.ID_MEDIDA_ARTICULO IS NULL) THEN
    NEW.ID_MEDIDA_ARTICULO = clave;
END
^


/* Trigger: MEDIDA_BI */
CREATE TRIGGER MEDIDA_BI FOR MEDIDA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_medida_id,1);

  IF (NEW.ID_MEDIDA IS NULL) THEN
    NEW.ID_MEDIDA = clave;

  new.baja = 'N';
END
^


/* Trigger: PAGO_FACTURAS_BI */
CREATE TRIGGER PAGO_FACTURAS_BI FOR PAGO_FACTURAS
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(GEN_PAGO_FACTURAS_ID,1);

  IF (NEW.ID_PAGO_FACTURAS IS NULL) THEN
    NEW.ID_PAGO_FACTURAS = clave;
END
^


/* Trigger: PERSONA_BI */
CREATE TRIGGER PERSONA_BI FOR PERSONA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_persona_id,1);

  IF (NEW.ID_PERSONA IS NULL) THEN
    NEW.ID_PERSONA = clave;
END
^


/* Trigger: PERSONA_PUNTOS_BI */
CREATE TRIGGER PERSONA_PUNTOS_BI FOR PERSONA_PUNTOS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_PERSONA_PUNTO IS NULL) THEN
    NEW.ID_PERSONA_PUNTO = GEN_ID(GEN_PERSONA_PUNTOS_ID,1);
END
^


/* Trigger: PERSONA_RELACION_BI */
CREATE TRIGGER PERSONA_RELACION_BI FOR PERSONA_RELACION
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_persona_relacion_id,1);

  IF (NEW.ID_PERSONA_RELACION IS NULL) THEN
    NEW.ID_PERSONA_RELACION = clave;
END
^


/* Trigger: POSICION_SUCURSAL_BI */
CREATE TRIGGER POSICION_SUCURSAL_BI FOR POSICION_SUCURSAL
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_posicion_sucursal_id,1);

  IF (NEW.ID_POSICION_SUCURSAL IS NULL) THEN
    NEW.ID_POSICION_SUCURSAL = clave;
END
^


/* Trigger: PRECIO_AU0 */
CREATE TRIGGER PRECIO_AU0 FOR PRECIO
ACTIVE AFTER UPDATE POSITION 0
as
begin

  if ((new.precio1 is null) or (new.precio1 = 0)) then
    new.precio1 = new.precio_venta;

  if ((new.precio2 is null) or (new.precio2 = 0)) then
    new.precio2 = new.precio_venta;

  if ((new.precio3 is null) or (new.precio3 = 0)) then
    new.precio3 = new.precio_venta;

  if ((new.precio4 is null) or (new.precio4 = 0)) then
    new.precio4 = new.precio_venta;

  if ((new.precio5 is null) or (new.precio5 = 0)) then
    new.precio5 = new.precio_venta;

end
^


/* Trigger: PRECIO_BI */
CREATE TRIGGER PRECIO_BI FOR PRECIO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_precio_id,1);

  IF (NEW.id_precio IS NULL) THEN
    NEW.id_precio = clave;
END
^


/* Trigger: PRODUCTO_AI0 */
CREATE TRIGGER PRODUCTO_AI0 FOR PRODUCTO
ACTIVE AFTER INSERT POSITION 0
AS
begin
 if (new.llevar_stock is null) then
    new.llevar_stock = 'S';

  if (new.baja is null) then
    new.baja = 'N';
end
^


/* Trigger: PRODUCTO_BI */
CREATE TRIGGER PRODUCTO_BI FOR PRODUCTO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_producto_id,1);

  IF (NEW.ID_PRODUCTO IS NULL) THEN
    NEW.ID_PRODUCTO = clave;
END
^


/* Trigger: PRODUCTO_CABECERA_AI0 */
CREATE TRIGGER PRODUCTO_CABECERA_AI0 FOR PRODUCTO_CABECERA
ACTIVE AFTER INSERT POSITION 0
AS
begin
 if (new.baja is null) then
    new.baja = 'N';
end
^


/* Trigger: PRODUCTO_CABECERA_BI */
CREATE TRIGGER PRODUCTO_CABECERA_BI FOR PRODUCTO_CABECERA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_producto_cabecera_id,1);

  IF (NEW.ID_PROD_CABECERA IS NULL) THEN
    NEW.ID_PROD_CABECERA = clave;
END
^


/* Trigger: STOCK_PRODUCTO_BI */
CREATE TRIGGER STOCK_PRODUCTO_BI FOR STOCK_PRODUCTO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_stock_producto_id,1);

  IF (NEW.ID_STOCK_PRODUCTO IS NULL) THEN
    NEW.ID_STOCK_PRODUCTO = clave;
END
^


/* Trigger: SUCURSAL_BI */
CREATE TRIGGER SUCURSAL_BI FOR SUCURSAL
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_sucursal_id,1);

  IF (NEW.ID_SUCURSAL IS NULL) THEN
    NEW.ID_SUCURSAL = clave;
END
^


/* Trigger: TIPO_ARTICULO_BI */
CREATE TRIGGER TIPO_ARTICULO_BI FOR TIPO_ARTICULO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_articulo_id,1);

  IF (NEW.ID_TIPO_ARTICULO IS NULL) THEN
    NEW.ID_TIPO_ARTICULO = clave;

  new.baja = 'N';
END
^


/* Trigger: TIPO_COMPROBANTE_BI */
CREATE TRIGGER TIPO_COMPROBANTE_BI FOR TIPO_COMPROBANTE
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_comprobante_id,1);

  IF (NEW.ID_TIPO_CPB IS NULL) THEN
    NEW.ID_TIPO_CPB = clave;
END
^


/* Trigger: TIPO_DOCUMENTO_BI */
CREATE TRIGGER TIPO_DOCUMENTO_BI FOR TIPO_DOCUMENTO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_documento_id,1);

  IF (NEW.ID_TIPO_DOC IS NULL) THEN
    NEW.ID_TIPO_DOC = clave;
END
^


/* Trigger: TIPO_EMPRESA_BI */
CREATE TRIGGER TIPO_EMPRESA_BI FOR TIPO_EMPRESA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_empresa_id,1);

  IF (NEW.ID_TIPO_EMPRESA IS NULL) THEN
    NEW.ID_TIPO_EMPRESA = clave;
END
^


/* Trigger: TIPO_FORMAPAGO_BI */
CREATE TRIGGER TIPO_FORMAPAGO_BI FOR TIPO_FORMAPAGO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_formapago_id,1);

  IF (NEW.ID_TIPO_FORMAPAGO IS NULL) THEN
    NEW.ID_TIPO_FORMAPAGO = clave;
END
^


/* Trigger: TIPO_IVA_BI */
CREATE TRIGGER TIPO_IVA_BI FOR TIPO_IVA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_iva_id,1);

  IF (NEW.ID_TIPO_IVA IS NULL) THEN
    NEW.ID_TIPO_IVA = clave;
END
^


/* Trigger: TIPO_MOVIMIENTO_BI */
CREATE TRIGGER TIPO_MOVIMIENTO_BI FOR TIPO_MOVIMIENTO
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_movimiento_id,1);

  IF (NEW.id_tipo_movimiento IS NULL) THEN
    NEW.id_tipo_movimiento = clave;
END
^


/* Trigger: TIPO_RELACION_BI */
CREATE TRIGGER TIPO_RELACION_BI FOR TIPO_RELACION
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_tipo_relacion_id,1);

  IF (NEW.ID_TIPO_RELACION IS NULL) THEN
    NEW.ID_TIPO_RELACION = clave;
END
^


SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE AA_CORREGIR_PRECIOS_NUEVA_TABLA
RETURNS (
    TOT INTEGER)
AS
declare variable ID_PRODUCTO integer;
declare variable ID_MEDIDA integer;
declare variable ID_SUCURSAL integer;
declare variable ID_PROD_CABECERA integer;
declare variable DESCRIPCION varchar(500);
declare variable PRECIO_COSTO numeric(15,4);
declare variable PRECIO_VENTA numeric(15,4);
declare variable COEF_GANANCIA numeric(15,4);
declare variable COEF_DESCUENTO numeric(15,4);
declare variable IMPUESTO_INTERNO numeric(15,4);
declare variable IMPUESTO_IVA numeric(15,4);
declare variable COD_CORTO varchar(20);
declare variable CODIGO_BARRA varchar(40);
declare variable STOCK_MAX numeric(15,4);
declare variable STOCK_MIN numeric(15,4);
declare variable LLEVAR_STOCK varchar(1);
declare variable PRECIO_COSTO_CIMPUESTOS numeric(15,4);
declare variable IMPUESTO_ADICIONAL1 numeric(15,4);
declare variable IMPUESTO_ADICIONAL2 numeric(15,4);
declare variable PRECIO1 numeric(15,4);
declare variable PRECIO2 numeric(15,4);
declare variable PRECIO3 numeric(15,4);
declare variable PRECIO4 numeric(15,4);
declare variable PRECIO5 numeric(15,4);
declare variable BAJA varchar(1);
begin
  /* Procedure Text */
  tot=0;
  for select p.id_producto, p.id_medida, p.id_prod_cabecera, p.descripcion, p.precio_costo, p.precio_venta, p.coef_ganancia, p.coef_descuento, p.impuesto_interno, p.impuesto_iva, p.cod_corto, p.codigo_barra, p.stock_max, p.stock_min, p.llevar_stock, p.precio_costo_cimpuestos, p.impuesto_adicional1, p.impuesto_adicional2, p.precio1, p.precio2, p.precio3, p.precio4, p.precio5, p.baja
  from producto p
  order by p.id_producto
  into :id_producto, :id_medida, :id_prod_cabecera, :descripcion, :precio_costo, :precio_venta, :coef_ganancia, :coef_descuento, :impuesto_interno, :impuesto_iva, :cod_corto, :codigo_barra, :stock_max, :stock_min, :llevar_stock, :precio_costo_cimpuestos, :impuesto_adicional1, :impuesto_adicional2, :precio1, :precio2, :precio3, :precio4, :precio5, :baja
  do
   begin
        select first 1 c.id_sucursal
        from configuracion c
        into :id_sucursal;

        if (id_sucursal is not null) then
         begin
            insert into precio (id_producto, id_sucursal, precio_costo, precio_venta, coef_ganancia, coef_descuento, impuesto_interno, impuesto_iva, precio_costo_cimpuestos, impuesto_adicional1, impuesto_adicional2, precio1, precio2, precio3, precio4, precio5)
            values (:id_producto, :id_sucursal, :precio_costo, :precio_venta, :coef_ganancia, :coef_descuento, :impuesto_interno, :impuesto_iva, :precio_costo_cimpuestos, :impuesto_adicional1, :impuesto_adicional2, :precio1, :precio2, :precio3, :precio4, :precio5);
            tot=tot+1;
         end

   end
  suspend;
end^


ALTER PROCEDURE AAAA_ASOCIAR_PRDO_STOCK (
    ID_SUCURSAL INTEGER)
AS
declare variable id_producto integer;
begin
  for select p.id_producto
  from producto p
  left join producto_cabecera pc on (p.id_prod_cabecera = pc.id_prod_cabecera)
  where trim(pc.descripcion) = ''
  into :id_producto
  do
  begin
    insert into stock_producto (id_producto, stock_actual, stock_min, stock_max, stock_repedido, stock_min_alarma,
                                id_posicion_sucursal)
    values (:id_producto, 0, 0, 0, 0, 0, :id_sucursal);
  end

  suspend;
end^


ALTER PROCEDURE AAAAA_ACTUALIZAR_TELEFONO
AS
declare variable id integer;
declare variable telefono varchar(100);
declare variable email varchar(100);
begin

  telefono = null;
  email = null;
  for select p.id_persona, p.telefono, p.email
  from persona p
  into :id, :telefono, :email
  do
  begin
      if ((:telefono is not null) or (:email is not null))  then
        insert into entidad_telefonos (id_entidad, id_persona, telefono, mail, descripcion)
        values (null, :id, :telefono, :email, null);
  end

  telefono = null;
  email = null;
  for select p.id_empresa, p.telefono, p.email
  from empresa p
  into :id, :telefono, :email
  do
  begin
      if ((:telefono is not null) or (:email is not null))  then
        insert into entidad_telefonos (id_entidad, id_persona, telefono, mail, descripcion)
        values (:id, null, :telefono, :email, null);
  end
end^


ALTER PROCEDURE ACOMODAR_INDICES
AS
declare variable max_id integer;
declare variable id_medida integer;
declare variable id_sucursal integer;
declare variable id_articulo integer;
begin

/*
  OBSERVACION: este procedimiento es para actualizar las PK y FK de los datos
  de las bases de LOPEZ y SPECIAL que fueron cargados antes de que se modifiquen
  los triggers que agregan el identificador de la base de datos al inicio de las
  PK. Solamente se debe correr una sola vez.
  Antes de correrlo se tiene que ejecutar el siguiente script para quitar PK y FK
  asociadas. Despues de correr el procedimiento se tiene que hacer un database
  compare para que se reestablezcan las PK y FK.

            ALTER TABLE ARTICULO DROP CONSTRAINT "Articulo FK_1";
            ALTER TABLE COMPROBANTE DROP CONSTRAINT FK_COMPROBANTE_1;
            ALTER TABLE COMPROBANTE DROP CONSTRAINT FK_COMPROBANTE_2;
            ALTER TABLE COMPROBANTE DROP CONSTRAINT FK_COMPROBANTE_3;
            ALTER TABLE COMPROBANTE DROP CONSTRAINT FK_COMPROBANTE_4;
            ALTER TABLE COMPROBANTE DROP CONSTRAINT FK_COMPROBANTE_5;
            ALTER TABLE COMPROBANTE_DETALLE DROP CONSTRAINT FK_COMPROBANTE_DETALLE_1;
            ALTER TABLE COMPROBANTE_DETALLE DROP CONSTRAINT FK_COMPROBANTE_DETALLE_2;
            ALTER TABLE COMPROBANTE_FORMA_PAGO DROP CONSTRAINT FK_COMPROBANTE_FORMA_PAGO_1;
            ALTER TABLE COMPROBANTE_FORMA_PAGO DROP CONSTRAINT FK_COMPROBANTE_FORMA_PAGO_2;
            ALTER TABLE CUENTA DROP CONSTRAINT FK_CUENTA_1;
            ALTER TABLE EMPRESA DROP CONSTRAINT "Empresa FK_1";
            ALTER TABLE EMPRESA DROP CONSTRAINT "Empresa FK_2";
            ALTER TABLE EMPRESA DROP CONSTRAINT "Empresa FK_3";
            ALTER TABLE EMPRESA_MARCA DROP CONSTRAINT "Empresa_Marca FK_1";
            ALTER TABLE EMPRESA_MARCA DROP CONSTRAINT "Empresa_Marca FK_2";
            ALTER TABLE MAIL_ADJUNTOS DROP CONSTRAINT FK_MAIL_ADJUNTOS_1;
            ALTER TABLE MAIL_CUENTAS DROP CONSTRAINT FK_MAIL_CUENTAS_1;
            ALTER TABLE MAIL_MENSAJE DROP CONSTRAINT FK_MAIL_MENSAJE_1;
            ALTER TABLE MEDIDA_ARTICULO DROP CONSTRAINT "Medida_Articulo FK_1";
            ALTER TABLE MEDIDA_ARTICULO DROP CONSTRAINT "Medida_Articulo FK_2";
            ALTER TABLE PERSONA DROP CONSTRAINT "Persona FK_1";
            ALTER TABLE PERSONA DROP CONSTRAINT "Persona FK_2";
            ALTER TABLE PERSONA DROP CONSTRAINT "Persona FK_3";
            ALTER TABLE PERSONA_RELACION DROP CONSTRAINT "Persona_Relacion FK_1";
            ALTER TABLE PERSONA_RELACION DROP CONSTRAINT "Persona_Relacion FK_2";
            ALTER TABLE PERSONA_RELACION DROP CONSTRAINT "Persona_Relacion FK_3";
            ALTER TABLE PERSONA_RELACION DROP CONSTRAINT "Persona_Relacion FK_4";
            ALTER TABLE POSICION_SUCURSAL DROP CONSTRAINT "Posicion_Producto FK_3";
            ALTER TABLE PRODUCTO DROP CONSTRAINT "Producto FK_1";
            ALTER TABLE PRODUCTO_CABECERA DROP CONSTRAINT "Producto_Cabecera FK_1";
            ALTER TABLE PRODUCTO_CABECERA DROP CONSTRAINT "Producto_Cabecera FK_2";
            ALTER TABLE STOCK_PRODUCTO DROP CONSTRAINT FK_STOCK_PRODUCTO_1;
            ALTER TABLE STOCK_PRODUCTO DROP CONSTRAINT FK_STOCK_PRODUCTO_2;
            
            ALTER TABLE PRODUCTO DROP CONSTRAINT "Producto PK";
            ALTER TABLE PRODUCTO_CABECERA DROP CONSTRAINT "Producto_Cabecera PK";
            ALTER TABLE COLOR DROP CONSTRAINT PK_COLOR_1
*/

     
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

--PARA ESTAS TABLAS HACER UNA TABLE DATA COMPARER
--TIPO_COMPROBANTE
/*$$IBEC$$   max_id = GEN_ID(gen_tipo_comprobante_id, 0);
  update tipo_comprobante t
  set t.id_tipo_cpb = :id_sucursal||t.id_tipo_cpb
  where t.id_tipo_cpb <> 0
    and t.id_tipo_cpb <= :max_id; $$IBEC$$*/

--TIPO_DOCUMENTO
/*$$IBEC$$   max_id = GEN_ID(gen_tipo_documento_id, 0);
  update tipo_documento t
  set t.id_tipo_doc = :id_sucursal||t.id_tipo_doc
  where t.id_tipo_doc <> 0
    and t.id_tipo_doc <= :max_id; $$IBEC$$*/

--TIPO_FORMAPAGO
/*$$IBEC$$   max_id = GEN_ID(gen_tipo_formapago_id, 0);
  update tipo_formapago t
  set t.id_tipo_formapago = :id_sucursal||t.id_tipo_formapago
  where t.id_tipo_formapago <> 0
    and t.id_tipo_formapago <= :max_id; $$IBEC$$*/

--TIPO_IVA
/*$$IBEC$$   max_id = GEN_ID(gen_tipo_iva_id, 0);
  update tipo_iva t
  set t.id_tipo_iva = :id_sucursal||t.id_tipo_iva
  where t.id_tipo_iva <> 0
    and t.id_tipo_iva <= :max_id; $$IBEC$$*/

--TIPO_RELACION
/*$$IBEC$$   max_id = GEN_ID(gen_tipo_relacion_id, 0);
  update tipo_relacion t
  set t.id_tipo_relacion = :id_sucursal||t.id_tipo_relacion
  where t.id_tipo_relacion <> 0
    and t.id_tipo_relacion <= :max_id; $$IBEC$$*/


--COLOR
  max_id = GEN_ID(gen_color_id, 0);    --obtengo el ultimo id generado
  update COLOR C
  set C.ID_COLOR = :id_sucursal||C.id_color --actualizo la PK actual con el numero de la suc adelante
  where c.id_color <> 0 --al PK 0 que es Sin Color no le hago nada
    and c.id_color <= :max_id; --solamente lo que son menores o igual al max_id calculado
                               --por si lo corro dos veces no siga concatenando el numero de la suc a la PK

--MARCA
  max_id = GEN_ID(gen_marca_id, 0);
  update marca m
  set m.id_marca = :id_sucursal||m.id_marca
  where m.id_marca <> 0
    and m.id_marca <= :max_id;

--MEDIDA
  max_id = GEN_ID(gen_medida_id, 0);
  update medida m
  set m.id_medida = :id_sucursal||m.id_medida
  where m.id_medida <> 0
    and m.id_medida <= :max_id;

--TIPO_ARTICULO
  max_id = GEN_ID(gen_tipo_articulo_id, 0);
  update tipo_articulo t
  set t.id_tipo_articulo = :id_sucursal||t.id_tipo_articulo
  where t.id_tipo_articulo <> 0
    and t.id_tipo_articulo <= :max_id;

--TIPO_EMPRESA
  max_id = GEN_ID(gen_tipo_empresa_id, 0);
  update tipo_empresa t
  set t.id_tipo_empresa = :id_sucursal||t.id_tipo_empresa
  where t.id_tipo_empresa <> 0
    and t.id_tipo_empresa <= :max_id;

--ARTICULO
  max_id = GEN_ID(gen_articulo_id, 0);
  update ARTICULO A
  set A.id_articulo = :id_sucursal||a.id_articulo,
      A.ID_TIPO_ARTICULO = :id_sucursal||a.id_tipo_articulo
  where a.id_articulo <= :max_id;

--EMPRESA
  max_id = GEN_ID(gen_empresa_id, 0);
  update EMPRESA E
  set E.id_empresa = :id_sucursal||e.id_empresa,
      E.id_tipo_iva = :id_sucursal||e.id_tipo_iva,
      E.id_tipo_empresa = :id_sucursal||e.id_tipo_empresa
  where e.id_empresa <= :max_id;

--EMPRESA_MARCA
  max_id = GEN_ID(gen_empresa_marca_id, 0);
  update EMPRESA_MARCA e
  set e.id = :id_sucursal||e.id,
      e.id_empresa = :id_sucursal||e.id_empresa,
      e.id_marca = :id_sucursal||e.id_marca
  where e.id <= :max_id;

--MEDIDA_ARTICULO
  for select m.id_medida, m.id_articulo
  from medida_articulo m
  where m.id_medida_articulo is null
  into :id_medida, :id_articulo
  do
  begin
    max_id = :id_sucursal||GEN_ID(gen_medida_articulo_id, 1);

    update MEDIDA_ARTICULO M
       set M.id_medida_articulo = :max_id
    where m.id_articulo = :id_articulo
      and m.id_medida = :id_medida;
  end

  max_id = GEN_ID(gen_medida_articulo_id, 0);
  update MEDIDA_ARTICULO M
  set M.id_articulo = :id_sucursal||m.id_articulo,
      M.id_medida = :id_sucursal||m.id_medida
  where m.id_medida_articulo <= :id_sucursal||:max_id;

--PERSONA
  max_id = GEN_ID(gen_persona_id, 0);
  update PERSONA P
  set P.id_persona = :id_sucursal||p.id_persona,
      P.id_tipo_doc = :id_sucursal||p.id_tipo_doc,
      P.id_tipo_iva = :id_sucursal||p.id_tipo_iva
  where p.id_persona <= :max_id;

--PRODUCTO_CABECERA
  max_id = GEN_ID(gen_producto_cabecera_id, 0);
  update PRODUCTO_CABECERA P
  set P.id_prod_cabecera = :id_sucursal||p.id_prod_cabecera,
      P.id_articulo = :id_sucursal||p.id_articulo,
      P.id_marca = :id_sucursal||p.id_marca,
      P.color = :id_sucursal||p.color
  where p.id_prod_cabecera <= :max_id;

--PRODUCTO
  max_id = GEN_ID(gen_producto_id, 0);
  update PRODUCTO P
  set P.id_producto = :id_sucursal||p.id_producto,
      P.id_prod_cabecera = :id_sucursal||p.id_prod_cabecera,
      P.id_medida = :id_sucursal||p.id_medida
  where p.id_producto <= :max_id;

  suspend;
end^


ALTER PROCEDURE ACTIVAR_TRIGGERS (
    TIPO VARCHAR(1))
AS
declare variable sentencia char(100);
begin
  if ((tipo = 'S') or (tipo = 'T')) then --TRIGGERS DEL SISTEMA
  begin
    for select 'ALTER TRIGGER ' || t.rdb$trigger_name || ' ACTIVE;'
    from rdb$triggers t
    where t.rdb$trigger_name like 'ADM_%'
    into :sentencia
    do
      execute statement sentencia;
  end

  if ((tipo = 'A') or (tipo = 'T')) then --TRIGGERS DE AUDITORIA
  begin
    for select 'ALTER TRIGGER ' || t.rdb$trigger_name || ' ACTIVE;'
    from rdb$triggers t
    where t.rdb$trigger_name like 'IBE$%'
    into :sentencia
    do
      execute statement sentencia;
  end
end^


ALTER PROCEDURE ACTUALIZAR_BASE
RETURNS (
    ACTUALIZACION VARCHAR(200))
AS
declare variable config_clave varchar(50);
declare variable id integer;
begin

/**********************************************************************
*   TABLA SUCURSAL => Registro 0, ADMINISTRADOR
**********************************************************************/
  id = null;
  select s.id_sucursal
  from sucursal s
  where s.id_sucursal = 0
  into :id;
  if (id is null) then
  begin
    insert into sucursal (id_sucursal, nombre, direccion, localidad, codigo_postal, telefono, email, baja,
                          reporte_titulo, reporte_subtitulo)
    values (0, 'ADMINISTRADOR', null, null, null, null, null, 'N', null, null);

    actualizacion = 'Se agrego el id_sucursal = 0 "ADMINISTRADOR"';
    suspend;
  end

/**********************************************************************
*   TABLA MARCA => Registro 0, SIN MARCA
**********************************************************************/
  id = null;
  select m.id_marca
  from marca m
  where m.id_marca = 0
  into :id;
  if (id is null) then
  begin
    insert into marca (id_marca, nombre_marca, baja, codigo_marca)
    values (0, 'SIN MARCA', 'N', 0);

    actualizacion = 'Se agrego el id_marca = 0 "SIN MARCA"';
    suspend;
  end

/**********************************************************************
*   TABLA COLOR => Registro 0, SIN COLOR
**********************************************************************/
  id = null;
  select c.id_color
  from color c
  where c.id_color = 0
  into :id;
  if (id is null) then
  begin
    insert into color (id_color, nombre, referencia, baja, codigo_color)
    values (0, 'SIN COLOR', null, 'N', 0);

    actualizacion = 'Se agrego el id_color = 0 "SIN COLOR"';
    suspend;
  end

/**********************************************************************
*   TABLA TIPO_FORMAPAGO => Registro 1, CUENTA CORRIENTE
**********************************************************************/
  id = null;
  select c.id_tipo_formapago
  from tipo_formapago c
  where c.id_tipo_formapago = 1
  into :id;
  if (id is null) then
  begin
       insert into tipo_formapago (id_tipo_formapago, descripcion, baja, "IF", desc_rec, cod_corto, genera_vuelto, columna_precio, modificable)
       values (1, 'CUENTA CORRIENTE', 'N', 'N', null, null, 'N', null, 'N');

       actualizacion = 'Se agrego el tipo forma de pago = 1 "CUENTA CORRIENTE"';
    suspend;
  end

/**********************************************************************
*   TABLA TIPO_FORMAPAGO => Registro 1, NOTA CREDITO
**********************************************************************/
  id = null;
  select c.id_tipo_formapago
  from tipo_formapago c
  where c.id_tipo_formapago = 2
  into :id;
  if (id is null) then
  begin
       insert into tipo_formapago (id_tipo_formapago, descripcion, baja, "IF", desc_rec, cod_corto, genera_vuelto, columna_precio, modificable)
       values (2, 'NOTA CREDITO', 'N', 'N', null, null, 'N', null, 'N');

       actualizacion = 'Se agrego el tipo forma de pago = 2 "NOTA CREDITO"';
    suspend;
  end

/**********************************************************************
*   TABLA TIPO_FORMAPAGO => Registro 1, TRANSFERENCIA
**********************************************************************/
  id = null;
  select c.id_tipo_formapago
  from tipo_formapago c
  where c.id_tipo_formapago = 3
  into :id;
  if (id is null) then
  begin
       insert into tipo_formapago (id_tipo_formapago, descripcion, baja, "IF", desc_rec, cod_corto, genera_vuelto, columna_precio, modificable)
       values (3, 'TRANSFERENCIA', 'N', 'N', null, null, 'N', null, 'N');

       actualizacion = 'Se agrego el tipo forma de pago = 3 "TRANSFERENCIA"';
    suspend;
  end

/**********************************************************************
*   TABLA CUENTA => Registro 1, CUENTA CORRIENTE
**********************************************************************/
  id = null;
  select c.id_cuenta
  from cuenta c
  where c.id_cuenta = 1
  into :id;
  if (id is null) then
  begin
       insert into cuenta (id_cuenta, medio_defecto, codigo, nombre_cuenta, nro_cta_bancaria, baja, id_sucursal, a_cta_corriente, a_nota_credito, modificable)
       values (1, 1, null, 'CUENTA CORRIENTE', null, 'N', 0, 'S', 'N', 'N');

       actualizacion = 'Se agrego la cuenta = 1 "CUENTA CORRIENTE"';
    suspend;
  end

/**********************************************************************
*   TABLA CUENTA => Registro 2, NOTA CREDITO
**********************************************************************/
  id = null;
  select c.id_cuenta
  from cuenta c
  where c.id_cuenta = 2
  into :id;
  if (id is null) then
  begin
       insert into cuenta (id_cuenta, medio_defecto, codigo, nombre_cuenta, nro_cta_bancaria, baja, id_sucursal, a_cta_corriente, a_nota_credito, modificable)
       values (2, 2, null, 'NOTA CREDITO', null, 'N', 0, 'N', 'S', 'N');

       actualizacion = 'Se agrego la cuenta = 2 "NOTA CREDITO"';
    suspend;
  end

/**********************************************************************
*   TABLA PERSONA => Registro 0, CONSUMIDOR FINAL
**********************************************************************/
  id = null;
  select p.id_persona
  from persona p
  where p.id_persona = 0
  into :id;
  if (id is null) then
  begin
    insert into persona (id_persona, id_tipo_iva, nombre, baja, descripcion, codigo_corto)
    values (0, 11, 'CONSUMIDOR FINAL', 'N', 'CONSUMIDOR FINAL', 0);

    insert into persona_relacion (id_persona_relacion, id_persona, id_relacion, id_empresa, id_sucursal)
    values (null, 0, 11, null, null);

    actualizacion = 'Se agrego el id_persona = 0 "CONSUMIDOR FINAL"';
    suspend;
  end

/**********************************************************************
*   TABLA CONFIGURACION
**********************************************************************/
  --colorCampoRequerido
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'colorCampoRequido'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('colorCampoRequido', null, null, '$00B3FFFF', null, null, null);

    actualizacion = 'Se agrego la variable "colorCampoRequido"';
    suspend;
  end

  --TextoPieDePagina
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'TextoPieDePagina'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('TextoPieDePagina', null, null, 'Sistema Gestin y Facturacin - ', null, null, null);

    actualizacion = 'Se agrego la variable "TextoPieDePagina"';
    suspend;
  end

  --provinciaPorDefecto
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'provinciaPorDefecto'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('provinciaPorDefecto', null, 1, '', null, null, null);

    actualizacion = 'Se agrego la variable "provinciaPorDefecto"';
    suspend;
  end

  --imp_ad1_nombre
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'imp_ad1_nombre'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('imp_ad1_nombre', null, null, 'Per. IB', null, null, null);

    actualizacion = 'Se agrego la variable "imp_ad1_nombre"';
    suspend;
  end

  --imp_ad2_nombre
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'imp_ad2_nombre'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('imp_ad2_nombre', null, null, 'Res. 3337', null, null, null);

    actualizacion = 'Se agrego la variable "imp_ad2_nombre"';
    suspend;
  end

  --PRECIO1
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'PRECIO1'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('PRECIO1', null, null, 'Efectivo', null, null, null);

    actualizacion = 'Se agrego la variable "PRECIO1"';
    suspend;
  end

  --PRECIO2
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'PRECIO2'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('PRECIO2', null, null, 'Tarjeta', null, null, null);

    actualizacion = 'Se agrego la variable "PRECIO2"';
    suspend;
  end

  --PRECIO3
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'PRECIO3'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('PRECIO3', null, null, 'Cheque', null, null, null);

    actualizacion = 'Se agrego la variable "PRECIO3"';
    suspend;
  end

  --PRECIO4
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'PRECIO4'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('PRECIO4', null, null, '', null, null, null);

    actualizacion = 'Se agrego la variable "PRECIO4"';
    suspend;
  end

  --PRECIO5
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'PRECIO5'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('PRECIO5', null, null, '', null, null, null);

    actualizacion = 'Se agrego la variable "PRECIO5"';
    suspend;
  end

  --MONTO_MAX_VENTA
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'MONTO_MAX_VENTA'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('MONTO_MAX_VENTA', null, 15000, '', null, null, null);

    actualizacion = 'Se agrego la variable "MONTO_MAX_VENTA"';
    suspend;
  end

  --ctacte_diasVencimiento
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'ctacte_diasVencimiento'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('ctacte_diasVencimiento', null, 15, '', null, null, null);

    actualizacion = 'Se agrego la variable "ctacte_diasVencimiento"';
    suspend;
  end

  --ctacte_credito
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'ctacte_credito'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('ctacte_credito', null, 5000, '', null, null, null);

    actualizacion = 'Se agrego la variable "ctacte_credito"';
    suspend;
  end

  --confirmarNotaPedido
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'confirmarNotaPedido'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('confirmarNotaPedido', null, null, 'SI', null, null, null);

    actualizacion = 'Se agrego la variable "confirmarNotaPedido"';
    suspend;
  end

  --notaCredito_diasVencimiento
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'notaCredito_diasVencimiento'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('notaCredito_diasVencimiento', null, 20, '', null, null, null);

    actualizacion = 'Se agrego la variable "notaCredito_diasVencimiento"';
    suspend;
  end

  --horaAperturaNegocio
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'horaAperturaNegocio'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('horaAperturaNegocio', null, null, '08:00:00', null, null, null);

    actualizacion = 'Se agrego la variable "horaAperturaNegocio"';
    suspend;
  end

  --horaCierreNegocio
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'horaCierreNegocio'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('horaCierreNegocio', null, null, '21:00:00', null, null, null);

    actualizacion = 'Se agrego la variable "horaCierreNegocio"';
    suspend;
  end

   --cuenta_defecto Cuenta por defecto en FP del cajero
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'cuenta_defecto'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('cuenta_defecto', null,112, '', null, null, null);

    actualizacion = 'Se agrego la variable "cuenta_defecto"';
    suspend;
  end

  --tipo_reporte_etiquetas Tipo de reporte del imprimir etiquetas (1: 3 etiq x fila, 2: 4 etiq x fila)
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'tipo_reporte_etiquetas'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('tipo_reporte_etiquetas', null, 1, '', null, null, 'Tipo de reporte del imprimir etiquetas (1: 3 etiq x fila, 2: 4 etiq x fila)');

    actualizacion = 'Se agrego la variable "tipo_reporte_etiquetas"';
    suspend;
  end

  --demoSistema
  config_clave = null;
  select c.clave
  from configuracion_variables c
  where c.clave = 'demoSistema'
  into :config_clave;
  if (config_clave is null) then
  begin
    insert into configuracion_variables (clave, fecha, numero, texto, nivel, grupo, descripcion)
    values ('demoSistema', null, null, 'NO', null, null, 'En SI me indica que el sistema es una demo que caduca en la FECHA especificada');

    actualizacion = 'Se agrego la variable "demoSistema"';
    suspend;
  end
end^


ALTER PROCEDURE ACTUALIZAR_IMPORTES (
    COEF_AUMENTO_COSTO NUMERIC(15,4),
    COEF_AUMENTO_VENTA NUMERIC(15,4),
    ID_PRECIO INTEGER,
    TIPOCALCULO INTEGER,
    ACTUALIZAR_IMPUESTOS INTEGER,
    IMPUESTO_IVA NUMERIC(15,4),
    IMPUESTO_ADICIONAL1 NUMERIC(15,4),
    IMPUESTO_ADICIONAL2 NUMERIC(15,4),
    PRECIO1 NUMERIC(15,4),
    PRECIO2 NUMERIC(15,4),
    PRECIO3 NUMERIC(15,4),
    PRECIO4 NUMERIC(15,4),
    PRECIO5 NUMERIC(15,4))
RETURNS (
    SALIDA INTEGER)
AS
declare variable precio_costo numeric(15,4);
declare variable precio_venta numeric(15,4);
declare variable coef_ganancia numeric(15,4);
declare variable precio_costo_cimp numeric(15,4);
declare variable imp_iva numeric(15,4);
declare variable imp_ad1 numeric(15,4);
declare variable imp_ad2 numeric(15,4);
declare variable precio_1 numeric(15,4);
declare variable precio_2 numeric(15,4);
declare variable precio_3 numeric(15,4);
declare variable precio_4 numeric(15,4);
declare variable precio_5 numeric(15,4);
declare variable coef_descuento numeric(15,4);
declare variable impuesto_interno numeric(15,4);
declare variable variable_precio varchar(10);
begin
  if (:actualizar_impuestos = 1) then --si es uno entonces actualizo los impuestos
    update precio p
    set p.impuesto_iva = :impuesto_iva,
        p.impuesto_adicional1 = :impuesto_adicional1,
        p.impuesto_adicional2 = :impuesto_adicional2
    where (p.id_precio = :id_precio);

  select  coef_descuento, impuesto_interno ,precio_costo, precio_venta, coef_ganancia, impuesto_iva, impuesto_adicional1, impuesto_adicional2, precio1, precio2, precio3, precio4, precio5
  from precio pr
  where pr.id_precio = :id_precio
  into :coef_descuento, :impuesto_interno ,:precio_costo, :precio_venta, :coef_ganancia, :imp_iva, :imp_ad1, :imp_ad2,  :precio_1, :precio_2, :precio_3, :precio_4, :precio_5;

  if (:coef_descuento is null) then
    coef_descuento = 0;

  if (:impuesto_interno is null) then
    impuesto_interno = 0;

  if (:precio_costo is null) then
    precio_costo = 0;

  if (:precio_venta is null) then
    precio_venta = 0;

  if (:coef_ganancia is null) then
    coef_ganancia = 0;

  if (:imp_iva is null) then
    imp_iva = 0;

  if (:imp_ad1 is null) then
    imp_ad1 = 0;

  if (:imp_ad2 is null) then
    imp_ad2 = 0;

  if (:precio_costo is null) then
    precio_costo = 0;

  if (:precio_venta is null) then
    precio_venta = 0;

  if (:precio_1 is null) then
    precio_1 = 0;

  if (:precio_2 is null) then
    precio_2 = 0;

  if (:precio_3 is null) then
    precio_3 = 0;

  if (:precio_4 is null) then
    precio_4 = 0;

  if (:precio_5 is null) then
    precio_5 = 0;

  if (:tipocalculo = 1) then --para cuando el inc/dec vienen expresado en porcentaje
  begin
    precio_costo = :precio_costo + (:precio_costo * (:coef_aumento_costo / 100));
    precio_costo_cimp = :precio_costo + (:precio_costo * :imp_ad1) + (:precio_costo * :imp_ad2) + (:precio_costo * :imp_iva);
    precio_venta = :precio_venta + (:precio_venta * (:coef_aumento_venta / 100));
    precio_1 = :precio_1 + (:precio_1 * (:precio1 / 100));
    precio_2 = :precio_2 + (:precio_2 * (:precio2 / 100));
    precio_3 = :precio_3 + (:precio_3 * (:precio3 / 100));
    precio_4 = :precio_4 + (:precio_4 * (:precio4 / 100));
    precio_5 = :precio_5 + (:precio_5 * (:precio5 / 100));

    if (:precio_costo_cimp <> 0) then
      coef_ganancia = ((:precio_venta / :precio_costo_cimp) - 1);
  end
  else --para cuando el inc/dec vienen expresado en dinero
  begin
    precio_costo = :precio_costo + :coef_aumento_costo;
    precio_costo_cimp = :precio_costo + (:precio_costo * :imp_ad1) + (:precio_costo * :imp_ad2) + (:precio_costo * :imp_iva);
    precio_venta = :precio_venta + :coef_aumento_venta;
    precio_1 = :precio_1 + :precio1;
    precio_2 = :precio_2 + :precio2;
    precio_3 = :precio_3 + :precio3;
    precio_4 = :precio_4 + :precio4;
    precio_5 = :precio_5 + :precio5;

    if (:precio_costo_cimp <> 0) then
      coef_ganancia = ((:precio_venta / :precio_costo_cimp) - 1);
  end

  update precio p
  set p.coef_descuento = :coef_descuento,
      p.impuesto_interno = :impuesto_interno,
      p.precio_costo = :precio_costo,
      p.precio_costo_cimpuestos = :precio_costo_cimp,
      p.precio_venta = :precio_venta,
      p.coef_ganancia = :coef_ganancia,
      p.precio1 = :precio_1,
      p.precio2 = :precio_2,
      p.precio3 = :precio_3,
      p.precio4 = :precio_4,
      p.precio5 = :precio_5
  where (p.id_precio = :id_precio);

  select cv.texto
  from configuracion_variables cv
  where cv.clave = 'PRECIO1'
  into :variable_precio;

  if (variable_precio = '') then
  begin
    update precio p
      set p.precio1 = :precio_venta
    where (p.id_precio = :id_precio);
  end

  select cv.texto
  from configuracion_variables cv
  where cv.clave = 'PRECIO2'
  into :variable_precio;

  if (variable_precio = '') then
  begin
    update precio p
      set p.precio2 = :precio_venta
    where (p.id_precio = :id_precio);
  end

  select cv.texto
  from configuracion_variables cv
  where cv.clave = 'PRECIO3'
  into :variable_precio;

  if (variable_precio = '') then
  begin
    update precio p
      set p.precio3 = :precio_venta
    where (p.id_precio = :id_precio);
  end

  select cv.texto
  from configuracion_variables cv
  where cv.clave = 'PRECIO4'
  into :variable_precio;

  if (variable_precio = '') then
  begin
    update precio p
      set p.precio4 = :precio_venta
    where (p.id_precio = :id_precio);
  end

  select cv.texto
  from configuracion_variables cv
  where cv.clave = 'PRECIO5'
  into :variable_precio;

  if (variable_precio = '') then
  begin
    update precio p
      set p.precio5 = :precio_venta
    where (p.id_precio = :id_precio);
  end

  salida = 1;

  suspend;
end^


ALTER PROCEDURE ACUMULAR_PERSONA_PUNTOS (
    ID_PERSONA_COMPRA INTEGER,
    MONTO_COMPRA NUMERIC(15,2))
AS
declare variable id_persona integer;
declare variable monto numeric(15,2);
declare variable puntos_mayor_monto numeric(15,2);
declare variable puntos_menor_monto numeric(15,2);
declare variable puntos_acumulados numeric(15,2);
declare variable baja varchar(1);
begin
    select p.id_persona
    from persona p
    where p.id_persona = :id_persona_compra
    into :id_persona;

    if (id_persona is not null) then
    begin
        select pp.id_persona, pp.monto, pp.puntos_mayor_monto, pp.puntos_menor_monto, pp.puntos_acumulados, pp.baja
        from persona_puntos pp
        where pp.id_persona = :id_persona
        into :id_persona ,:monto, :puntos_mayor_monto, :puntos_menor_monto, :puntos_acumulados, :baja;

        if ((id_persona is not null) and (baja = 'N')) then
        begin

            if (monto_compra >= monto) then
            begin
                puntos_acumulados = puntos_acumulados + puntos_mayor_monto;
            end
            else
            begin
                puntos_acumulados = puntos_acumulados + puntos_menor_monto;
            end

            update persona_puntos pp
            set pp.puntos_acumulados = :puntos_acumulados
            where pp.id_persona = :id_persona;

        end
    end


  suspend;
end^


ALTER PROCEDURE ASOCIAR_PRODUCTO_PTO_SALIDA (
    ID_PRODUCTO INTEGER,
    STOCK_ACTUAL NUMERIC(15,4),
    STOCK_MIN NUMERIC(15,4),
    STOCK_MAX NUMERIC(15,4))
AS
declare variable id_posicion_sucursal integer;
declare variable id_stock_producto integer;
begin
    select first 1 ps.ID_POSICION_SUCURSAL
    from posicion_sucursal ps
    where (ps.punto_salida = 'S')
    into :ID_POSICION_SUCURSAL;

    select id_stock_producto
    from stock_producto sp
    where (sp.id_producto = :id_producto) and (sp.id_posicion_sucursal = :id_posicion_sucursal)
    into :id_stock_producto;

    if (id_stock_producto is null) then
    begin
        INSERT INTO STOCK_PRODUCTO (ID_PRODUCTO, ID_POSICION_SUCURSAL, STOCK_ACTUAL, STOCK_MIN, STOCK_MAX, STOCK_REPEDIDO, STOCK_MIN_ALARMA)
        VALUES (:ID_PRODUCTO, :ID_POSICION_SUCURSAL, :STOCK_ACTUAL, :STOCK_MIN, :STOCK_MAX, 0, 0);
    end

  suspend;
end^


ALTER PROCEDURE CALC_CTACTE_GENERAL (
    TIPO INTEGER)
RETURNS (
    ID_PERSONA INTEGER,
    ID_PROVEEDOR INTEGER,
    VENCIMIENTO_DIAS INTEGER,
    LIMITE_DEUDA NUMERIC(15,2),
    DEBE NUMERIC(15,2),
    HABER NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    FECHA_ALTA DATE,
    FECHA_BAJA DATE)
AS
begin

--PARA LOS CLIENTES
  if (tipo = 0) then
  begin
    id_proveedor = null;
    for select cc.id_persona, cc.limite_deuda, cc.vencimiento_dias, cc.saldo, cc.fecha_alta, cc.fecha_baja
    from cuenta_corriente cc --por cada cuenta corriente
    where cc.id_persona is not null
    into :id_persona, :limite_deuda, :vencimiento_dias, :saldo, :fecha_alta, :fecha_baja
    do
    begin
      if (limite_deuda is null) then
        limite_deuda = 0;

      if (saldo is null) then
        saldo = 0;

      select sum(cpb.importe_venta) --sumo el importe de todas las facturas que no estan anuladas
      from comprobante cpb
      where cpb.id_cliente = :id_persona --tipo 11 o saldo inicial de clientes
        and ((cpb.id_tipo_cpb = 11) or ((cpb.id_tipo_cpb = 17) and (cpb.id_cliente is not null)))
        and cpb.fecha_anulado is null
      into :debe;

      select sum(cfp.importe_real) --sumo el importe de todas las formas de pagos asociadas a las facturas
      from comprobante cpb    --que sean del tipo forma de pago <> a cuenta_corriente y nota credito
      left join comprobante_forma_pago cfp on (cpb.id_comprobante = cfp.id_comprobante)
      where cpb.id_cliente = :id_persona
        and cpb.id_tipo_cpb = 11 --FACTURAS
        and cpb.fecha_anulado is null
        and cfp.id_tipo_formapag > 2
      into :haber;

      if (:debe is null) then debe = 0;
      if (:haber is null) then haber = 0;

      saldo = :debe - :haber;

      suspend;
    end
  end

--PARA LOS PROVEEDORES
  if (tipo = 1) then
  begin
    id_persona = null;
    for select cc.id_proveedor, cc.limite_deuda, cc.vencimiento_dias, cc.saldo, cc.fecha_alta, cc.fecha_baja
    from cuenta_corriente cc --por cada cuenta corriente
    where cc.id_proveedor is not null
    into :id_proveedor, :limite_deuda, :vencimiento_dias, :saldo, :fecha_alta, :fecha_baja
    do
    begin
      if (limite_deuda is null) then
        limite_deuda = 0;

      if (saldo is null) then
        saldo = 0;

      select sum(cpb.importe_venta) --sumo el importe de todas las facturas que no estan anuladas
      from comprobante cpb
      where cpb.id_proveedor = :id_proveedor --tipo 13 o saldo inicial de proveedores
        and ((cpb.id_tipo_cpb = 13) or ((cpb.id_tipo_cpb = 16) and (cpb.id_proveedor is not null)))
        and cpb.fecha_anulado is null
      into :haber;

      select sum(cfp.importe_real) --sumo el importe de todas las formas de pagos asociadas a las facturas
      from comprobante cpb    --que sean del tipo forma de pago <> a cuenta_corriente y nota credito
      left join comprobante_forma_pago cfp on (cpb.id_comprobante = cfp.id_comprobante)
      where cpb.id_proveedor = :id_proveedor
        and cpb.id_tipo_cpb = 13 --FACTURAS COMPRA
        and cpb.fecha_anulado is null
        and cfp.id_tipo_formapag > 2
      into :debe;

      if (:debe is null) then debe = 0;
      if (:haber is null) then haber = 0;

      saldo = :debe - :haber;

      suspend;
    end
  end

end^


ALTER PROCEDURE CALC_CTACTE_INDIVIDUAL_CLIENTE (
    ID_SUCURSAL INTEGER,
    ID_PERSONA INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE)
RETURNS (
    TIPO_COMPROBANTE VARCHAR(100),
    ID_COMPROBANTE INTEGER,
    ID_COMPROB_FP INTEGER,
    ID_CUENTA INTEGER,
    ID_VENDEDOR INTEGER,
    ID_TIPO_IVA INTEGER,
    ID_TIPO_FP INTEGER,
    FECHA DATE,
    OBSERVACION VARCHAR(500),
    FECHA_FP DATE,
    DEBE NUMERIC(15,4),
    HABER NUMERIC(15,4),
    SALDO_CPB NUMERIC(15,4),
    ORDEN1 INTEGER,
    ORDEN2 INTEGER)
AS
declare variable id_tipo_cpb integer;
declare variable id_tipo_movimiento integer;
declare variable id_comp_estado integer;
declare variable codigo varchar(50);
declare variable base_imponible numeric(15,4);
declare variable importe_total numeric(15,4);
declare variable porc_iva numeric(15,4);
declare variable importe_iva numeric(15,4);
declare variable porc_descuento numeric(15,4);
declare variable importe_descuento numeric(15,4);
declare variable encabezado varchar(500);
declare variable pie varchar(500);
declare variable fecha_cobrada date;
declare variable fecha_enviada date;
declare variable fecha_impresa date;
declare variable fecha_vencimiento date;
declare variable punto_venta integer;
declare variable numero_cpb integer;
declare variable fecha_anulado date;
declare variable importe_fp numeric(15,4);
declare variable id_recibo_op integer;
begin

  tipo_comprobante = 'SALDO ANTERIOR';
  orden1 = 0; --Indica el Orden principal, Primero los saldos iniciales y despues las facturas y pagos
  orden2 = 0; --Indica el Orden secundario, Primero las Facturas y Despues los Pagos

  --FACTURAS ANTERIORES
  select sum(cpb.importe_venta)
  from comprobante cpb
  where (cpb.id_cliente = :id_persona) --todas las facturas o otros_ingresos que sean saldo inicial asociados al cliente
    and ((cpb.id_tipo_cpb = 11) or ((cpb.id_tipo_cpb = 17) and (cpb.id_cliente is not null)))
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(cpb.fecha as date) < :fecha_desde) --anteriores a la fecha desde
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
  into :debe;

  --PAGOS ANTERIORES
  select sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cpb.id_cliente = :id_persona)
    and (cpb.id_tipo_cpb = 11) --todos los pagos de las facturas
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(fp.fecha_fp as date) < :fecha_desde) --anteriores a la fecha desde
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
    and fp.id_tipo_formapag > 2
  into haber;

  if (debe is null) then debe = 0;
  if (haber is null) then haber = 0;
  suspend;


  --FACTURAS
  id_comprob_fp = null;
  for select cpb.id_comprobante, cpb.id_vendedor, cpb.id_tipo_iva, cpb.id_comp_estado,
             cast(cpb.fecha as date), cpb.observacion, cpb.base_imponible, cpb.saldo, cpb.importe_venta,
             cpb.porc_iva, cpb.importe_iva, cpb.porc_descuento, cpb.importe_descuento,
             cpb.fecha_impresa, cpb.punto_venta, cpb.numero_cpb, cpb.fecha_anulado, cpb.codigo, cpb.id_tipo_cpb
  from comprobante cpb
  where (cpb.id_cliente = :id_persona) --todas las facturas o otros_ingresos que sean saldo inicial asociados al cliente
    and ((cpb.id_tipo_cpb = 11) or ((cpb.id_tipo_cpb = 17) and (cpb.id_cliente is not null)))
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(cpb.fecha as date) between :fecha_desde and :fecha_hasta) --entre les fechas desde y hasta
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
  into :id_comprobante, :id_vendedor, :id_tipo_iva,
       :id_comp_estado, :fecha, :observacion, :base_imponible,
       :saldo_cpb, :importe_total, :porc_iva, :importe_iva, :porc_descuento, :importe_descuento,
       :fecha_impresa, :punto_venta, :numero_cpb, :fecha_anulado, :codigo, :id_tipo_cpb
  do
  begin
    if (punto_venta is null) then
       punto_venta = 0;

    if (numero_cpb is null) then
       numero_cpb = 0;

    if (:id_tipo_cpb = 11) then
       tipo_comprobante = 'FACTURA '||:codigo; --lpad(:punto_venta,4,'0')||'-'||lpad(:numero_cpb,8,'0');
    else
       if (:id_tipo_cpb = 17) then
         tipo_comprobante = 'SALDO INICIAL CTA. CTE.';

    orden1 = 1;
    orden2 = 1;
    debe  = :importe_total;
    haber = 0;

    suspend;
  end

  --PAGOS
  id_comprobante = null;
  for select fp.id_comprob_fp, cpb.id_vendedor, cpb.id_tipo_iva, cpb.id_comp_estado,
             cast(cpb.fecha as date), cpb.observacion, cpb.base_imponible, cpb.saldo, cpb.importe_venta,
             cpb.porc_iva, cpb.importe_iva, cpb.porc_descuento, cpb.importe_descuento,
             cpb.fecha_impresa, cpb.punto_venta, cpb.numero_cpb, cpb.fecha_anulado,
             fp.id_tipo_formapag, fp.cuenta_ingreso, fp.importe_real, cast(fp.fecha_fp as date), cpb.codigo,
             fp.id_recibo_op
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cpb.id_cliente = :id_persona)
    and (cpb.id_tipo_cpb = 11) --todos los pagos de las facturas
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(fp.fecha_fp as date) between :fecha_desde and :fecha_hasta) --entre les fechas desde y hasta
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
    and fp.id_tipo_formapag > 2 --que el tipo de forma de pago no sea cuenta corriente
  into :id_comprob_fp, :id_vendedor, :id_tipo_iva, :id_comp_estado,
       :fecha, :observacion, :base_imponible, :saldo_cpb, :importe_total,
       :porc_iva, :importe_iva, :porc_descuento, :importe_descuento,
       :fecha_impresa, :punto_venta, :numero_cpb, :fecha_anulado,
       :id_tipo_fp, :id_cuenta, :importe_fp, :fecha_fp, :codigo, :id_recibo_op
  do
  begin
    if (:id_recibo_op is not null) then --si se pago con un recibo
    begin
       --busco el recibo con el cual se pago
       select co.punto_venta, co.numero_cpb
       from comprobante co
       where co.id_comprobante = :id_recibo_op
       into :punto_venta, :numero_cpb;
       if (punto_venta is null) then
          punto_venta = 0;
       if (numero_cpb is null) then
          numero_cpb = 0;

       tipo_comprobante = 'PAGO FACTURA '||:codigo||' - RECIBO '||lpad(:punto_venta,4,'0')||'-'||lpad(:numero_cpb,8,'0');
    end
    else
        tipo_comprobante = 'PAGO FACTURA '||:codigo;

    orden1 = 1;
    orden2 = 2;
    debe  = 0;
    haber = :importe_fp;
    saldo_cpb = null;
    fecha = :fecha_fp;
    id_vendedor = null;

    suspend;
  end

end^


ALTER PROCEDURE CALC_CTACTE_INDIVIDUAL_PROV (
    ID_SUCURSAL INTEGER,
    ID_PROVEEDOR INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE)
RETURNS (
    TIPO_COMPROBANTE VARCHAR(30),
    ID_COMPROBANTE INTEGER,
    ID_COMPROB_FP INTEGER,
    ID_CUENTA INTEGER,
    ID_VENDEDOR INTEGER,
    ID_TIPO_IVA INTEGER,
    ID_TIPO_FP INTEGER,
    FECHA DATE,
    OBSERVACION VARCHAR(500),
    FECHA_FP DATE,
    DEBE NUMERIC(15,4),
    HABER NUMERIC(15,4),
    SALDO_CPB NUMERIC(15,4),
    ORDEN1 INTEGER,
    ORDEN2 INTEGER)
AS
declare variable id_tipo_cpb integer;
declare variable id_tipo_movimiento integer;
declare variable id_comp_estado integer;
declare variable codigo varchar(50);
declare variable base_imponible numeric(15,4);
declare variable importe_total numeric(15,4);
declare variable porc_iva numeric(15,4);
declare variable importe_iva numeric(15,4);
declare variable porc_descuento numeric(15,4);
declare variable importe_descuento numeric(15,4);
declare variable encabezado varchar(500);
declare variable pie varchar(500);
declare variable fecha_cobrada date;
declare variable fecha_enviada date;
declare variable fecha_impresa date;
declare variable fecha_vencimiento date;
declare variable punto_venta integer;
declare variable numero_cpb integer;
declare variable fecha_anulado date;
declare variable importe_fp numeric(15,4);
declare variable id_recibo_op integer;
declare variable op_pv integer;
declare variable op_num integer;
begin
--UTILIZO EL CAMPO FECHA_COBRADA DEL COMPROBANTE PORQUE AHI SE GUARDA LA FECHA ORIGINAL DE LA FACTURA
  tipo_comprobante = 'SALDO ANTERIOR';
  orden1 = 0; --Indica el Orden principal, Primero los saldos iniciales y despues las facturas y pagos
  orden2 = 0; --Indica el Orden secundario, Primero las Facturas y Despues los Pagos

--FACTURAS ANTERIORES
  select sum(cpb.importe_total)
  from comprobante cpb
  where (cpb.id_proveedor = :id_proveedor)  --tipo 13 o saldo inicial proveedor
    and ((cpb.id_tipo_cpb = 13) or ((cpb.id_tipo_cpb = 16) and (cpb.id_proveedor is not null)))
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(cpb.fecha_cobrada as date) < :fecha_desde) --anteriores a la fecha desde
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
  into :haber;

--PAGOS ANTERIORES
  select sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cpb.id_proveedor = :id_proveedor)
    and (cpb.id_tipo_cpb = 13) --todos los pagos de las facturas de compra
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(fp.fecha_fp as date) < :fecha_desde) --anteriores a la fecha desde
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
    and fp.id_tipo_formapag > 2
  into :debe;

  if (debe is null) then debe = 0;
  if (haber is null) then haber = 0;
  suspend;


--FACTURAS
  id_comprob_fp = null;
  for select cpb.id_comprobante, cpb.id_vendedor, cpb.id_tipo_iva, cpb.id_comp_estado,
             cast(cpb.fecha_cobrada as date), cpb.observacion, cpb.base_imponible, cpb.saldo, cpb.importe_venta,
             cpb.porc_iva, cpb.importe_iva, cpb.porc_descuento, cpb.importe_descuento,
             cpb.fecha_impresa, cpb.punto_venta, cpb.numero_cpb, cpb.fecha_anulado, cpb.id_tipo_cpb
  from comprobante cpb
  where (cpb.id_proveedor = :id_proveedor) --tipo 13 o saldo inicial proveedor
    and ((cpb.id_tipo_cpb = 13) or ((cpb.id_tipo_cpb = 16) and (cpb.id_proveedor is not null)))
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(cpb.fecha_cobrada as date) between :fecha_desde and :fecha_hasta) --entre les fechas desde y hasta
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
  into :id_comprobante, :id_vendedor, :id_tipo_iva,
       :id_comp_estado, :fecha, :observacion, :base_imponible,
       :saldo_cpb, :importe_total, :porc_iva, :importe_iva, :porc_descuento, :importe_descuento,
       :fecha_impresa, :punto_venta, :numero_cpb, :fecha_anulado, :id_tipo_cpb
  do
  begin
    if (punto_venta is null) then
       punto_venta = 0;

    if (numero_cpb is null) then
       numero_cpb = 0;

    if (:id_tipo_cpb = 13) then
        tipo_comprobante = 'FACTURA '||lpad(:punto_venta,4,'0')||'-'||lpad(:numero_cpb,8,'0');
    else
       if (:id_tipo_cpb = 16) then
         tipo_comprobante = 'SALDO INICIAL CTA. CTE.';

    orden1 = 1;
    orden2 = 1;
    haber  = :importe_total;
    debe = 0;

    suspend;
  end

--PAGOS
  id_comprobante = null;
  for select fp.id_comprob_fp, cpb.id_vendedor, cpb.id_tipo_iva, cpb.id_comp_estado,
             cast(cpb.fecha_cobrada as date), cpb.observacion, cpb.base_imponible, cpb.saldo, cpb.importe_total,
             cpb.porc_iva, cpb.importe_iva, cpb.porc_descuento, cpb.importe_descuento,
             cpb.fecha_impresa, cpb.punto_venta, cpb.numero_cpb, cpb.fecha_anulado,
             fp.id_tipo_formapag, fp.cuenta_ingreso, fp.importe_real, cast(fp.fecha_fp as date), fp.id_recibo_op
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cpb.id_proveedor = :id_proveedor)
    and (cpb.id_tipo_cpb = 13) --todos los pagos de las facturas de compra
    and (cpb.fecha_anulado is null) --que no esten anuladas
    and (cast(fp.fecha_fp as date) between :fecha_desde and :fecha_hasta) --entre les fechas desde y hasta
    and ((id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
    and fp.id_tipo_formapag > 2 --que el tipo de forma de pago no sea cuenta corriente
  into :id_comprob_fp, :id_vendedor, :id_tipo_iva, :id_comp_estado,
       :fecha, :observacion, :base_imponible, :saldo_cpb, :importe_total,
       :porc_iva, :importe_iva, :porc_descuento, :importe_descuento,
       :fecha_impresa, :punto_venta, :numero_cpb, :fecha_anulado,
       :id_tipo_fp, :id_cuenta, :importe_fp, :fecha_fp, :id_recibo_op
  do
  begin
    if (punto_venta is null) then
       punto_venta = 0;
    if (numero_cpb is null) then
       numero_cpb = 0;

    if (:id_recibo_op is not null) then --si se pago con un recibo
    begin
       --busco el recibo con el cual se pago
       select co.punto_venta, co.numero_cpb
       from comprobante co
       where co.id_comprobante = :id_recibo_op
       into :op_pv, :op_num;
       if (op_num is null) then
          op_num = 0;
       if (op_pv is null) then
          op_pv = 0;

       tipo_comprobante = 'PAGO FACTURA '||lpad(:punto_venta,4,'0')||'-'||lpad(:numero_cpb,8,'0')||' - O.PAGO '||lpad(:op_pv,4,'0')||'-'||lpad(:op_num,8,'0');
    end
    else
       tipo_comprobante = 'PAGO FACTURA '||lpad(:punto_venta,4,'0')||'-'||lpad(:numero_cpb,8,'0');

    orden1 = 1;
    orden2 = 2;
    haber  = 0;
    debe = :importe_fp;
    saldo_cpb = null;
    fecha = :fecha_fp;
    id_vendedor = null;

    suspend;
  end

end^


ALTER PROCEDURE CALC_SALDOS_CUENTAS (
    FECHA_HASTA DATE)
RETURNS (
    GRUPO INTEGER,
    ID_SUCURSAL INTEGER,
    ID_CUENTA INTEGER,
    IMPORTE NUMERIC(15,4))
AS
begin
--Ver que pasa con las anulaciones, creo que ahi que poner un campo anulado
--Ver que hacemos con las confirmaciones, solamente que se tome en cuenta los confirmados o no

  --INGRESOS
  grupo = 1;
  for select fp.cuenta_ingreso, cpb.id_sucursal, sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  left join tipo_comprobante tpo on (cpb.id_tipo_cpb = tpo.id_tipo_cpb)
  where (cast (fp.fecha_fp as Date) <= :fecha_hasta) --pagos realizados hasta la fecha
    and fp.cuenta_ingreso is not null --que sean de ingreso
    and ((cpb.fecha_anulado > :fecha_hasta) or (cpb.fecha_anulado is null)) --que no esten anulados
    and fp.id_tipo_formapag > 2 --
    and tpo.signo_cobro_pago <> 0
  group by fp.cuenta_ingreso, cpb.id_sucursal
  into :id_cuenta, :id_sucursal, :importe
  do
    suspend;

  --EGRESOS
  grupo = 1;
  for select fp.cuenta_egreso, cpb.id_sucursal, -sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  left join tipo_comprobante tpo on (cpb.id_tipo_cpb = tpo.id_tipo_cpb)
  where (cast (fp.fecha_fp as Date) <= :fecha_hasta) --pagos realizados hasta la fecha
    and fp.cuenta_egreso is not null --que sean de egreso
    and ((cpb.fecha_anulado > :fecha_hasta) or (cpb.fecha_anulado is null)) --que no esten anulados
    and fp.id_tipo_formapag > 2
    and tpo.signo_cobro_pago <> 0
  group by fp.cuenta_egreso, cpb.id_sucursal
  into :id_cuenta, :id_sucursal, :importe
  do
    suspend;

  --CUENTA CORRIENTE CLIENTE
  grupo = 2;
  for select fp.cuenta_ingreso, cpb.id_sucursal, sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cast (fp.fecha_fp as Date) <= :fecha_hasta) --pagos realizados hasta la fecha
    and fp.cuenta_ingreso is not null --que sean de ingreso
    and ((cpb.fecha_anulado > :fecha_hasta) or (cpb.fecha_anulado is null)) --que no esten anulados
    and fp.id_tipo_formapag = 1
  group by fp.cuenta_ingreso, cpb.id_sucursal
  into :id_cuenta, :id_sucursal, :importe
  do
    suspend;

  --CUENTA CORRIENTE PROVEEDOR
  grupo = 3;
  for select fp.cuenta_egreso, cpb.id_sucursal, -sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cast (fp.fecha_fp as Date) <= :fecha_hasta) --pagos realizados hasta la fecha
    and fp.cuenta_egreso is not null --que sean de egreso
    and ((cpb.fecha_anulado > :fecha_hasta) or (cpb.fecha_anulado is null)) --que no esten anulados
    and fp.id_tipo_formapag = 1
  group by fp.cuenta_egreso, cpb.id_sucursal
  into :id_cuenta, :id_sucursal, :importe
  do
    suspend;

  --NOTAS CREDITO
  grupo = 4;
  for select fp.cuenta_egreso, cpb.id_sucursal, -sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante cpb on (fp.id_comprobante = cpb.id_comprobante)
  where (cast (fp.fecha_fp as Date) <= :fecha_hasta) --pagos realizados hasta la fecha
    and fp.cuenta_egreso is not null --que sean de ingreso
    and ((cpb.fecha_anulado > :fecha_hasta) or (cpb.fecha_anulado is null)) --que no esten anulados
    and fp.id_tipo_formapag = 2
    and (cast(cpb.fecha_vencimiento as date) >= :fecha_hasta)
  group by fp.cuenta_egreso, cpb.id_sucursal
  into :id_cuenta, :id_sucursal, :importe
  do
    suspend;
end^


ALTER PROCEDURE CORREGIR_PRECIOS_ANTIGUOS
RETURNS (
    SQL VARCHAR(2000))
AS
declare variable CLAVE varchar(50);
declare variable SETEO varchar(100);
declare variable SETEON varchar(100);
begin
  seteo='';
  seteon='';

  for select c.clave
  from configuracion_variables c
  where (c.clave like 'PRECIO%')and((c.texto='')or(c.texto is null))
  into :clave
  do
   begin
       if ((seteo<>'')and(seteo is not null)) then seteo=seteo||',';
       if ((seteon<>'')and(seteon is not null)) then seteon=seteon||' and ';

       seteo=seteo||'p.'||clave||'=p.precio_venta';
       seteon=seteon||'(p.'||clave||'<>p.precio_venta)';
   end

  sql='update precio p set '||seteo||' where '||seteon;
  execute statement sql;
  suspend;
end^


ALTER PROCEDURE CTACTA_DEUDA_ATRASADA (
    TIPO INTEGER)
RETURNS (
    ID_CLIENTE INTEGER,
    CODIGO_CORTO INTEGER,
    NOMBRE VARCHAR(200),
    SALDO_CPB NUMERIC(15,4),
    ID_PROVEEDOR INTEGER,
    FECHA_VENCIM DATE)
AS
declare variable punto_venta integer;
declare variable numero_cpb integer;
declare variable vencim_dias integer;
begin
  id_cliente = null;
  id_proveedor = null;

--PARA LOS CLIENTE
  if (tipo = 0) then
  begin
    for select p.id_persona, p.codigo_corto, p.nombre, cc.vencimiento_dias, sum(c.saldo)
    from cuenta_corriente cc
    left join persona p on (cc.id_persona = p.id_persona)
    left join comprobante c on (c.id_cliente = p.id_persona)
    where cast(c.fecha as date) < incdate(current_date, -cc.vencimiento_dias, 0, 0)
      and c.saldo > 0
      and (c.fecha_anulado is null)
    group by p.id_persona, p.codigo_corto, p.nombre, cc.vencimiento_dias
    order by p.nombre, p.codigo_corto
    into :id_cliente, :codigo_corto, :nombre, :vencim_dias, :saldo_cpb
    do
    begin
      fecha_vencim = incdate(current_date, -:vencim_dias, 0, 0);
      suspend;
    end
  end

--PARA LOS PROVEEDORES
  if (tipo = 1) then
  begin
    for select e.id_empresa, e.codigo_corto, e.nombre, cc.vencimiento_dias, sum(c.saldo)
    from cuenta_corriente cc
    left join empresa e on (cc.id_proveedor = e.id_empresa)
    left join comprobante c on (c.id_proveedor = cc.id_proveedor)
    where cast(c.fecha_cobrada as date) < incdate(current_date, -cc.vencimiento_dias, 0, 0)
      and c.saldo > 0
      and (c.fecha_anulado is null)
    group by e.id_empresa, e.codigo_corto, e.nombre, cc.vencimiento_dias
    order by e.nombre, e.codigo_corto
    into :id_proveedor, :codigo_corto, :nombre, :vencim_dias, :saldo_cpb
    do
    begin
      fecha_vencim = incdate(current_date, -:vencim_dias, 0, 0);
      suspend;
    end
  end
end^


ALTER PROCEDURE CTACTA_DEUDA_ATRASADA_CLIENTE (
    ID_CLIENTE INTEGER)
RETURNS (
    ID_CLIENTE_OUT INTEGER,
    CODIGO_CORTO INTEGER,
    NOMBRE VARCHAR(200),
    SALDO_CPB NUMERIC(15,4),
    FECHA_VENCIM DATE)
AS
declare variable punto_venta integer;
declare variable numero_cpb integer;
declare variable vencim_dias integer;
begin
    for select p.id_persona, p.codigo_corto, p.nombre, cc.vencimiento_dias, sum(c.saldo)
    from cuenta_corriente cc
    left join persona p on (cc.id_persona = p.id_persona)
    left join comprobante c on (c.id_cliente = p.id_persona)
    where cast(c.fecha as date) < incdate(current_date, -cc.vencimiento_dias, 0, 0)
      and c.saldo > 0
      and (c.fecha_anulado is null)
      and ((cc.id_persona = :id_cliente) or (:id_cliente = -1))
    group by p.id_persona, p.codigo_corto, p.nombre, cc.vencimiento_dias
    order by p.nombre, p.codigo_corto
    into :id_cliente_out, :codigo_corto, :nombre, :vencim_dias, :saldo_cpb
    do
    begin
    fecha_vencim = incdate(current_date, -:vencim_dias, 0, 0);

    if (:id_cliente_out is not null) then
       suspend;
    end
end^


ALTER PROCEDURE CTACTA_DEUDA_ATRASADA_PROVEEDOR (
    ID_PROVEEDOR INTEGER)
RETURNS (
    ID_PROVEEDOR_OUT INTEGER,
    CODIGO_CORTO INTEGER,
    NOMBRE VARCHAR(200),
    SALDO_CPB NUMERIC(15,4),
    FECHA_VENCIM DATE)
AS
declare variable punto_venta integer;
declare variable numero_cpb integer;
declare variable vencim_dias integer;
begin
    for select e.id_empresa, e.codigo_corto, e.nombre, cc.vencimiento_dias, sum(c.saldo)
    from cuenta_corriente cc
    left join empresa e on (cc.id_proveedor = e.id_empresa)
    left join comprobante c on (c.id_proveedor = cc.id_proveedor)
    where cast(c.fecha_cobrada as date) < incdate(current_date, -cc.vencimiento_dias, 0, 0)
      and c.saldo > 0
      and (c.fecha_anulado is null)
      and ((cc.id_proveedor = :id_proveedor) or (:id_proveedor = -1))
    group by e.id_empresa, e.codigo_corto, e.nombre, cc.vencimiento_dias
    order by e.nombre, e.codigo_corto
    into :id_proveedor_out, :codigo_corto, :nombre, :vencim_dias, :saldo_cpb
    do
    begin
      fecha_vencim = incdate(current_date, -:vencim_dias, 0, 0);

      if (:id_proveedor_out is not null) then
          suspend;
    end
end^


ALTER PROCEDURE CTACTE_GENERAL (
    ID_PROVEEDOR INTEGER,
    ID_CLIENTE INTEGER)
RETURNS (
    ID_CLIENTE_OUT INTEGER,
    LIMITE_DEUDA NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    FECHA_ALTA DATE,
    FECHA_BAJA DATE,
    DEBE NUMERIC(15,2),
    HABER NUMERIC(15,2),
    NOMBRE VARCHAR(200),
    NUMERO_DOC VARCHAR(50),
    LOCALIDAD VARCHAR(200),
    CODIGO_POSTAL VARCHAR(20),
    CUIT_CUIL VARCHAR(30),
    BAJA VARCHAR(1),
    NOMBRE_PROVINCIA VARCHAR(50),
    NOMBRE_TIPO_IVA VARCHAR(50),
    COD_IVA VARCHAR(10),
    NOMBRE_TIPO_DOC VARCHAR(20),
    CODIGO_CORTO INTEGER,
    VENCIMIENTO_DIAS INTEGER,
    ID_PROVEEDOR_OUT INTEGER,
    DEUDA_VENCIDA VARCHAR(1))
AS
declare variable aux_tiene_deuda integer;
begin
--PARA LOS CLIENTES
  if (:id_cliente is not null) then
  begin
    for select cc.id_persona, cc.limite_deuda, cc.vencimiento_dias, cc.saldo, cc.fecha_alta, cc.fecha_baja, cc.debe, cc.haber,
               cli.codigo_corto, cli.nombre, cli.numero_doc, cli.localidad, cli.codigo_postal, cli.cuit_cuil, cli.baja,
               pro.nombre_provincia, iva.nombre_tipo_iva, iva.abreviatura as cod_iva, doc.nombre_tipo_doc
    from calc_ctacte_general(0) cc --paso que es un cliente
    left join persona cli on (cc.id_persona = cli.id_persona)
    left join tipo_documento doc on (cli.id_tipo_doc = doc.id_tipo_doc)
    left join tipo_iva iva on (cli.id_tipo_iva = iva.id_tipo_iva)
    left join provincia pro on (cli.id_provincia = pro.id_provincia)
    where ((cc.id_persona = :id_cliente) or (:id_cliente = -1))
    order by cli.nombre
    into :id_cliente_out, :limite_deuda, :vencimiento_dias, :saldo, :fecha_alta, :fecha_baja, :debe, :haber, :codigo_corto, :nombre,
         :numero_doc, :localidad, :codigo_postal, :cuit_cuil, :baja, :nombre_provincia, :nombre_tipo_iva, :cod_iva,
         :nombre_tipo_doc
    do
    begin
      deuda_vencida = 'N';
      aux_tiene_deuda = null;
      select d.id_cliente_out
      from ctacta_deuda_atrasada_cliente(:id_cliente_out) d
      into :aux_tiene_deuda;
      if (:aux_tiene_deuda is not null) then
         deuda_vencida = 'S';

      suspend;
    end
  end

--PARA LOS PROVEEDORES
  if (:id_proveedor is not null) then
  begin
    numero_doc= null;
    nombre_tipo_doc= null;
    for select cc.id_proveedor, cc.limite_deuda, cc.vencimiento_dias, cc.saldo, cc.fecha_alta, cc.fecha_baja, cc.debe, cc.haber,
               emp.codigo_corto, emp.nombre, emp.localidad, emp.codigo_postal, emp.cuit_cuil, emp.baja,
               pro.nombre_provincia, iva.nombre_tipo_iva, iva.abreviatura as cod_iva
    from calc_ctacte_general(1) cc --paso que es un proveedor
    left join empresa emp on (cc.id_proveedor = emp.id_empresa)
    left join tipo_iva iva on (emp.id_tipo_iva = iva.id_tipo_iva)
    left join provincia pro on (emp.id_provincia = pro.id_provincia)
    where ((cc.id_proveedor = :id_proveedor) or (:id_proveedor = -1))
    order by emp.nombre
    into :id_proveedor_out, :limite_deuda, :vencimiento_dias, :saldo, :fecha_alta, :fecha_baja, :debe, :haber, :codigo_corto, :nombre,
         :localidad, :codigo_postal, :cuit_cuil, :baja, :nombre_provincia, :nombre_tipo_iva, :cod_iva
    do
    begin
      deuda_vencida = 'N';
      aux_tiene_deuda = null;
      select d.id_proveedor_out
      from ctacta_deuda_atrasada_proveedor(:id_proveedor_out) d
      into :aux_tiene_deuda;
      if (:aux_tiene_deuda is not null) then
         deuda_vencida = 'S';

      suspend;
    end
  end

end^


ALTER PROCEDURE CTACTE_INDIVIDUAL (
    ID_SUCURSAL INTEGER,
    ID_CLIENTE INTEGER,
    ID_PROVEEDOR INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE)
RETURNS (
    TIPO_COMPROBANTE VARCHAR(100),
    ID_COMPROBANTE INTEGER,
    ID_CUENTA INTEGER,
    ID_VENDEDOR INTEGER,
    ID_TIPO_IVA INTEGER,
    ID_TIPO_FP INTEGER,
    FECHA DATE,
    OBSERVACION VARCHAR(500),
    FECHA_FP DATE,
    DEBE NUMERIC(15,4),
    HABER NUMERIC(15,4),
    SALDO_CPB NUMERIC(15,4),
    SALDO NUMERIC(15,4),
    ID_COMPROB_FP INTEGER)
AS
begin
  saldo = 0;

  --PARA LOS CLIENTES
  if (id_cliente is not null) then
  begin
    id_proveedor = null;
    for select cc.tipo_comprobante, cc.id_comprobante, cc.id_cuenta, cc.id_vendedor, cc.id_tipo_iva,
               cc.id_tipo_fp, cc.fecha, cc.observacion, cc.fecha_fp, cc.debe, cc.haber, cc.saldo_cpb, cc.id_comprob_fp
    from calc_ctacte_individual_cliente(:id_sucursal, :id_cliente, :fecha_desde, :fecha_hasta) cc
    order by cc.orden1, cc.fecha, cc.orden2
    into :tipo_comprobante, :id_comprobante, :id_cuenta, :id_vendedor, :id_tipo_iva, :id_tipo_fp,
         :fecha, :observacion, :fecha_fp, :debe, :haber, :saldo_cpb, :id_comprob_fp
    do
    begin
      saldo = saldo + :debe - :haber;

      if (:tipo_comprobante = 'SALDO ANTERIOR') then --si es el saldo anterior
      begin
        debe = null;--vacio el debe
        haber = null;--vacio el haber
      end

      suspend;
    end
  end


  --PARA LOS PROVEEDORES
  if (id_proveedor is not null) then
  begin
    id_cliente = null;
    for select cc.tipo_comprobante, cc.id_comprobante, cc.id_cuenta, cc.id_vendedor, cc.id_tipo_iva, cc.id_tipo_fp,
               cc.fecha, cc.observacion, cc.fecha_fp, cc.debe, cc.haber, cc.saldo_cpb, cc.id_comprob_fp
    from calc_ctacte_individual_prov(:id_sucursal, :id_proveedor, :fecha_desde, :fecha_hasta) cc
    order by cc.orden1, cc.fecha, cc.orden2
    into :tipo_comprobante, :id_comprobante, :id_cuenta, :id_vendedor, :id_tipo_iva, :id_tipo_fp, :fecha, :observacion,
         :fecha_fp, :debe, :haber, :saldo_cpb, :id_comprob_fp
    do
    begin
      saldo = saldo + :debe - :haber;

      if (:tipo_comprobante = 'SALDO ANTERIOR') then --si es el saldo anterior
      begin
        debe = null;--vacio el debe
        haber = null;--vacio el haber
      end

      suspend;
    end
  end

end^


ALTER PROCEDURE DESACTIVAR_TRIGGERS (
    TIPO VARCHAR(1))
AS
declare variable sentencia char(100);
begin
  if ((tipo = 'S') or (tipo = 'T')) then --TRIGGERS DEL SISTEMA
  begin
    for select 'ALTER TRIGGER ' || t.rdb$trigger_name || ' INACTIVE;'
    from rdb$triggers t
    where t.rdb$trigger_name like 'ADM_%'
    into :sentencia
    do
      execute statement sentencia;
  end

  if ((tipo = 'A') or (tipo = 'T')) then --TRIGGERS DEL SISTEMA
  begin
    for select 'ALTER TRIGGER ' || t.rdb$trigger_name || ' INACTIVE;'
    from rdb$triggers t
    where t.rdb$trigger_name like 'IBE$%'
    into :sentencia
    do
      execute statement sentencia;
  end
end^


ALTER PROCEDURE DEVOLUCION_UPDATE_STOCK (
    ID_COMPROBANTE INTEGER,
    ACCION INTEGER)
AS
declare variable cantidad numeric(15,2);
declare variable id_stock_producto integer;
begin
  for select c.id_stock_producto, c.cantidad
  from comprobante_detalle c
  where c.id_comprobante = :id_comprobante
  into :id_stock_producto, :cantidad
  do
  begin
    if (:accion = 1) then --CONFIRMAR
    begin
      if (id_stock_producto is not null) then --si no es nulo el id_stock
      begin
        update stock_producto sp
        set sp.stock_actual = sp.stock_actual - :cantidad
        where (sp.id_stock_producto = :id_stock_producto);
      end
    end
    else
    if (:accion = 2) then --ANULAR
    begin
      if (id_stock_producto is not null) then --si no es nulo el id_stock
      begin
        update stock_producto sp
        set sp.stock_actual = sp.stock_actual + :cantidad
        where (sp.id_stock_producto = :id_stock_producto);
      end
    end
  end
end^


ALTER PROCEDURE ESTADISTICA_DETALLE_MOVIMIENTOS (
    FECHADESDE DATE,
    FECHAHASTA DATE,
    ID_SUCURSAL_INGRESO INTEGER)
RETURNS (
    IMPORTE_VENTA NUMERIC(15,2),
    NUMERO_CPB INTEGER,
    PUNTO_VENTA INTEGER,
    CODIGO VARCHAR(50),
    FECHA TIMESTAMP,
    OBSERVACION VARCHAR(500),
    TIPO_COMPROBANTE VARCHAR(100),
    TIPO_MOVIMIENTO VARCHAR(20),
    NOMBRE_ENTIDAD VARCHAR(100),
    ID_COMPROBANTE INTEGER)
AS
declare variable id_sucursal integer;
declare variable id_proveedor integer;
declare variable id_cliente integer;
declare variable cuenta_ingreso integer;
declare variable cuenta_egreso integer;
begin
--Ver que pasa con las anulaciones, creo que ahi que poner un campo anulado
--Ver que hacemos con las confirmaciones, solamente que se tome en cuenta los confirmados o no

  --busco todos los comprobantes que generan ingresos o egresos en las cuentas
  for select c.id_comprobante, c.id_sucursal, c.id_proveedor, c.id_cliente, c.codigo,
             c.fecha, c.observacion, c.punto_venta, c.numero_cpb, c.importe_venta, tc.nombre_tipo_cpb
  from comprobante c
  left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
  where (cast(c.fecha as date) between :fechadesde and :fechahasta) --entre las fechas
    and ((c.id_sucursal = :id_sucursal_ingreso) or (:id_sucursal_ingreso = -1))
    and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
    and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
  order by c.fecha
  into :id_comprobante, :id_sucursal, :id_proveedor, :id_cliente, :codigo, :fecha, :observacion, :punto_venta,
       :numero_cpb, :importe_venta, :tipo_comprobante
  do
  begin
    cuenta_ingreso = null;
    cuenta_egreso = null;

    if (importe_venta is null) then
      importe_venta = 0;

    --veo si fue un ingreso, egreso o transferencia
    select first 1 cfp.cuenta_ingreso, cfp.cuenta_egreso
    from comprobante_forma_pago cfp
    where cfp.id_comprobante = :id_comprobante
    into :cuenta_ingreso, :cuenta_egreso;

    if (cuenta_ingreso is not null) then
      tipo_movimiento = 'INGRESO';

    if (cuenta_egreso is not null) then
      tipo_movimiento = 'EGRESO';

    if ((cuenta_egreso is not null) and (cuenta_ingreso is not null)) then
    begin
      tipo_movimiento = 'TRANSFERENCIA';
      nombre_entidad = 'TRANSFERENCIA';
    end

    --si el cliente no es null muestro el nombre
    if (id_cliente is not null) then
    begin
      select p.nombre
      from persona p
      where p.id_persona = :id_cliente
      into :nombre_entidad;
    end

    --si el proveedor no es null muestro el nombre
    if (id_proveedor is not null) then
    begin
      select e.nombre
      from empresa e
      where e.id_empresa = :id_proveedor
      into :nombre_entidad;
    end

    suspend;
  end

end^


ALTER PROCEDURE ESTADISTICA_DIARIA_GLOBAL (
    FECHA_DESDE DATE,
    FECHA_HASTA DATE,
    ID_SUCURSAL INTEGER,
    TIPO_CPB INTEGER)
RETURNS (
    FECHA DATE,
    INGRESO NUMERIC(15,2),
    EGRESO NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    SALDODIARIO NUMERIC(15,2))
AS
declare variable monto numeric(15,2);
declare variable cta_ingreso integer;
declare variable cta_egreso integer;
declare variable sin_movimientos integer;
declare variable fecha_anulado date;
begin
--Ver que pasa con las anulaciones, creo que ahi que poner un campo anulado
--Ver que hacemos con las confirmaciones, solamente que se tome en cuenta los confirmados o no

  ingreso = 0;
  egreso = 0;
  saldodiario = 0;
  saldo = 0;
  sin_movimientos = 0;--por defecto no hay movimientos en el mes

  --calculo el saldo anterior descartando las anulaciones
  for select fp.cuenta_ingreso, fp.cuenta_egreso, sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante c on (c.id_comprobante = fp.id_comprobante)
  left join tipo_comprobante tpo on (c.id_tipo_cpb = tpo.id_tipo_cpb)
  where 1 = 1
    and cast(fp.fecha_fp as date) < :fecha_desde
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and (c.fecha_anulado is null)
    and ((c.id_tipo_cpb = :tipo_cpb) or (:tipo_cpb = -1))
    and (c.id_tipo_cpb <> 21) --descarto los comprobantes de TRANSFERENCIA
    and tpo.signo_cobro_pago <> 0
  group by fp.cuenta_ingreso, fp.cuenta_egreso
  into :cta_ingreso, :cta_egreso, :monto
  do
  begin
    if (:cta_egreso is not null) then --EGRESOS
      saldo = saldo - :monto;

    if (:cta_ingreso is not null) then --INGRESO
      saldo = saldo + :monto;
  end

  for select distinct cast(fp.fecha_fp as date) --por cada dia del mes que tuvo comprobantes cargados
  from comprobante_forma_pago fp
  left join comprobante c on (c.id_comprobante = fp.id_comprobante)
  left join tipo_comprobante tpo on (c.id_tipo_cpb = tpo.id_tipo_cpb)
  where 1 = 1
    and cast(fp.fecha_fp as date) between :fecha_desde and :fecha_hasta
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and (c.fecha_anulado is null)
    and ((c.id_tipo_cpb = :tipo_cpb) or (:tipo_cpb = -1))
    and (c.id_tipo_cpb <> 21) --descarto los comprobantes de TRANSFERENCIA
    and tpo.signo_cobro_pago <> 0
  into :fecha
  do
  begin
    sin_movimientos = 1;--si entra aca es porque hay al menos un movimiento
    ingreso = 0;
    egreso = 0;
    saldodiario = 0;
    fecha_anulado = null;

    for select fp.cuenta_ingreso, fp.cuenta_egreso, sum(fp.importe_real)
    from comprobante_forma_pago fp
    left join comprobante c on (c.id_comprobante = fp.id_comprobante)
    left join tipo_comprobante tpo on (c.id_tipo_cpb = tpo.id_tipo_cpb)
    where 1 = 1
      and cast(fp.fecha_fp as date) = :fecha
      and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
      and (c.fecha_anulado is null)
      and ((c.id_tipo_cpb = :tipo_cpb) or (:tipo_cpb = -1))
      and (c.id_tipo_cpb <> 21) --descarto los comprobantes de TRANSFERENCIA
      and tpo.signo_cobro_pago <> 0
    group by fp.cuenta_ingreso, fp.cuenta_egreso
    into :cta_ingreso, :cta_egreso, :monto
    do
    begin
      if (:cta_egreso is not null) then --EGRESOS
        egreso = egreso + :monto;

      if (:cta_ingreso is not null) then --INGRESO
        ingreso = ingreso + :monto;
    end

    saldodiario = ingreso - egreso;
    saldo = saldo + saldodiario;

    if ((egreso <> 0) or (ingreso <> 0)) then
      suspend;
  end

  if (sin_movimientos = 0) then
    suspend;
end^


ALTER PROCEDURE ESTADISTICA_DIARIA_MOV_INTERNOS (
    FECHA_DESDE DATE,
    FECHA_HASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    FECHA DATE,
    INGRESO NUMERIC(15,2),
    EGRESO NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    SALDODIARIO NUMERIC(15,2))
AS
declare variable monto numeric(15,2);
declare variable cta_ingreso integer;
declare variable cta_egreso integer;
declare variable sin_movimientos integer;
declare variable fecha_anulado date;
begin
  ingreso = 0;
  egreso = 0;
  saldodiario = 0;
  saldo = 0;
  sin_movimientos = 0;--por defecto no hay movimientos en el mes

  --calculo el saldo anterior descartando las anulaciones
  for select fp.cuenta_ingreso, fp.cuenta_egreso, sum(fp.importe_real)
  from comprobante_forma_pago fp
  left join comprobante c on (c.id_comprobante = fp.id_comprobante)
  where 1 = 1
    and cast(fp.fecha_fp as date) < :fecha_desde
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and (c.fecha_anulado is null)
    and (c.id_tipo_cpb between 16 and 17)
    and ((c.id_proveedor is null) and (c.id_cliente is null)) --descarto los que son saldo inicial de cta cte
  group by fp.cuenta_ingreso, fp.cuenta_egreso
  into :cta_ingreso, :cta_egreso, :monto
  do
  begin
    if (:cta_egreso is not null) then --EGRESOS
      saldo = saldo - :monto;

    if (:cta_ingreso is not null) then --INGRESO
      saldo = saldo + :monto;
  end

  for select distinct cast(fp.fecha_fp as date) --por cada dia del mes que tuvo comprobantes cargados
  from comprobante_forma_pago fp
  left join comprobante c on (c.id_comprobante = fp.id_comprobante)
  where 1 = 1
    and cast(fp.fecha_fp as date) between :fecha_desde and :fecha_hasta
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and (c.fecha_anulado is null)
    and (c.id_tipo_cpb between 16 and 17)
    and ((c.id_proveedor is null) and (c.id_cliente is null)) --descarto los que son saldo inicial de cta cte
  into :fecha
  do
  begin
    sin_movimientos = 1;--si entra aca es porque hay al menos un movimiento
    ingreso = 0;
    egreso = 0;
    saldodiario = 0;
    fecha_anulado = null;

    for select fp.cuenta_ingreso, fp.cuenta_egreso, sum(fp.importe_real)
    from comprobante_forma_pago fp
    left join comprobante c on (c.id_comprobante = fp.id_comprobante)
    where 1 = 1
      and cast(fp.fecha_fp as date) = :fecha
      and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
      and (c.fecha_anulado is null)
      and (c.id_tipo_cpb between 16 and 17)
      and ((c.id_proveedor is null) and (c.id_cliente is null)) --descarto los que son saldo inicial de cta cte
    group by fp.cuenta_ingreso, fp.cuenta_egreso
    into :cta_ingreso, :cta_egreso, :monto
    do
    begin
      if (:cta_egreso is not null) then --EGRESOS
        egreso = egreso + :monto;

      if (:cta_ingreso is not null) then --INGRESO
        ingreso = ingreso + :monto;
    end

    saldodiario = ingreso - egreso;
    saldo = saldo + saldodiario;

    if ((egreso <> 0) or (ingreso <> 0)) then
      suspend;
  end

  if (sin_movimientos = 0) then
    suspend;
end^


ALTER PROCEDURE ESTADISTICA_IE_MEDIO (
    FECHADESDE DATE,
    FECHAHASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    TOTAL_EGRESO NUMERIC(15,2),
    TOTAL_INGRESO NUMERIC(15,2),
    DESCRIPCION VARCHAR(100),
    TOTAL_TRANSFERENCIA NUMERIC(15,2))
AS
declare variable importe_real numeric(15,2);
declare variable id_tipo_formapag integer;
declare variable vencimiento_nc date;
begin
  --busco todos los comprobantes que generar ingresos o egresos y los agrupo por el tipo de forma de pago
  for select cfp.id_tipo_formapag, tfp.descripcion
  from comprobante c
  left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
  left join tipo_formapago tfp on (cfp.id_tipo_formapag = tfp.id_tipo_formapago)
  left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
  where (cast(cfp.fecha_fp as date) between :fechadesde and :fechahasta) --que esten en el rango de fechas
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
    and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
  group by cfp.id_tipo_formapag, tfp.descripcion
  order by cfp.id_tipo_formapag
  into :id_tipo_formapag, :descripcion
  do
  begin
    total_ingreso = 0;
    total_egreso = 0;
    total_transferencia = 0;

    --Todos los tipos de forma de pago que no sean TRANSFERENCIA
    if (id_tipo_formapag <> 2) then
    begin
      --obtengo el total de ingreso de las formas de pago para los comprobantes del tipo <> TRANSFERENCIA
      select sum(cfp.importe_real)
      from comprobante c
      left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
      left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
      where (cast(cfp.fecha_fp as date) between :fechadesde and :fechahasta) --que esten en el rango de fechas
        and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
        and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
        and (cfp.id_tipo_formapag = :id_tipo_formapag)
        and (cfp.cuenta_ingreso is not null) --ingresos
        and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
        and (c.id_tipo_cpb <> 21) --con Tipo Comprobante distinto de TANSFERENCIA
      into :total_ingreso;

      if (total_ingreso is null) then
        total_ingreso = 0;

      --obtengo el total de egreso de las formas de pago para los comprobantes del tipo <> TRANSFERENCIA
      select sum(cfp.importe_real)
      from comprobante c
      left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
      left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
      where (cast(cfp.fecha_fp as date) between :fechadesde and :fechahasta) --que esten en el rango de fechas
        and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
        and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
        and (cfp.id_tipo_formapag = :id_tipo_formapag)
        and (cfp.cuenta_egreso is not null) --egresos
        and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
        and (c.id_tipo_cpb <> 21) --con Tipo Comprobante distinto de TANSFERENCIA
      into :total_egreso;

      if (total_egreso is null) then
        total_egreso = 0;

      --si es un comprobante del tipo TRANSFERENCIAS
      select sum(cfp.importe_real)
      from comprobante c
      left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
      left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
      where (cast(cfp.fecha_fp as date) between :fechadesde and :fechahasta) --que esten en el rango de fechas
        and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
        and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
        and (cfp.id_tipo_formapag = :id_tipo_formapag)
        and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
        and (c.id_tipo_cpb = 21) --con Tipo Comprobante igual de TANSFERENCIA
      into :total_transferencia;

      if (total_transferencia is null) then
        total_transferencia = 0;
    end

    --Si la forma de pago es NOTA DE CREDITO
    if (id_tipo_formapag = 2) then
    begin
      select sum(cfp.importe_real)
      from comprobante c
      left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
      left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
      where (cast(cfp.fecha_fp as date) between :fechadesde and :fechahasta) --que esten en el rango de fechas
        and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
        and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
        and (cfp.id_tipo_formapag = :id_tipo_formapag)
        and (cfp.cuenta_egreso is not null)
        and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
        and (cast(c.fecha_vencimiento as date) >= :fechahasta) --que la nota de credito no este venciada
      into :total_egreso;

      if (total_egreso is null) then
        total_egreso = 0;
    end

    suspend;
  end
end^


ALTER PROCEDURE ESTADISTICA_PARTE_DIARIO (
    FECHADESDE DATE,
    FECHAHASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    SALDO_INICIAL NUMERIC(15,2),
    SALDO NUMERIC(15,2),
    TOTAL_INGRESO NUMERIC(15,2),
    TOTAL_EGRESO NUMERIC(15,2),
    TOTAL_TRANSFERENCIA NUMERIC(15,2),
    TOTAL_NOTA_CREDITO NUMERIC(15,2),
    TOTAL_CTA_CTE_CLIENTE NUMERIC(15,2),
    TOTAL_CTA_CTE_PROVEEDOR NUMERIC(15,2))
AS
declare variable cuenta_ingreso integer;
declare variable cuenta_egreso integer;
declare variable fecha_fp timestamp;
declare variable importe_real numeric(15,2);
declare variable tipo_formapago integer;
declare variable vencimiento_nc date;
declare variable tipo_comprobante integer;
begin
  total_transferencia = 0;
  total_nota_credito = 0;
  total_cta_cte_cliente = 0;
  total_cta_cte_proveedor = 0;
  saldo = 0;

  total_ingreso = 0;
  total_egreso = 0;
  saldo_inicial = 0;
  importe_real = 0;

  --CALCULO EL SALDO INICIAL
  for select cfp.cuenta_ingreso, cfp.cuenta_egreso, cfp.fecha_fp, cfp.importe_real
  from comprobante c
  left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
  left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
  where (cast(cfp.fecha_fp as date) < :fechadesde)
    and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
    and (c.id_tipo_cpb <> 21) --descarto los comprobantes de TRANSFERENCIA
  into :cuenta_ingreso, :cuenta_egreso, :fecha_fp, :importe_real
  do
  begin
    if (cuenta_ingreso is not null) then
      total_ingreso = total_ingreso + importe_real;
    else
      total_egreso = total_egreso + importe_real;

    saldo_inicial = total_ingreso - total_egreso;
  end

  --calculo los ingresos y los egresos
  total_ingreso = 0;
  total_egreso = 0;
  importe_real = 0;
  for select cfp.cuenta_ingreso, cfp.cuenta_egreso, cfp.fecha_fp, cfp.importe_real, cfp.id_tipo_formapag,
             cast(c.fecha_vencimiento as date), c.id_tipo_cpb
  from comprobante c
  left join comprobante_forma_pago cfp on (c.id_comprobante = cfp.id_comprobante)
  left join tipo_comprobante tc on (c.id_tipo_cpb = tc.id_tipo_cpb)
  where (cast(cfp.fecha_fp as date) between :fechadesde and :fechahasta) --que esten en el rango de fechas
    and ((c.fecha_anulado > :fechahasta) or (c.fecha_anulado is null)) --que no esten anulados
    and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1))
    and (tc.signo_cobro_pago <> 0) --que sean comprobantes de ingreso o egreso
  into :cuenta_ingreso, :cuenta_egreso, :fecha_fp, :importe_real, :tipo_formapago, :vencimiento_nc, :tipo_comprobante
  do
  begin
    --Todos los comprobantes <> de TRANSFERENCIA y Todas las formas de pagos <> de NOTA DE CREDITO y CUENTA CORRIENTE
    if ((:tipo_formapago > 2) and (:tipo_comprobante <> 21)) then
    begin
        if (cuenta_ingreso is not null) then
          total_ingreso = total_ingreso + importe_real;
        else
          total_egreso = total_egreso + importe_real;
    end

    --Todas las formas de pago = CUENTA CORRIENTE
    if (:tipo_formapago = 1) then
    begin
        if (cuenta_ingreso is not null) then --CUENTA CORRIENTE CLIENTE
          total_cta_cte_cliente = total_cta_cte_cliente + importe_real;
        else --CUENTA CORRIENTE PROVEEDOR
          total_cta_cte_proveedor = total_cta_cte_proveedor + importe_real;
    end

    --Todas las formas de pago = NOTAS DE CREDITO
    if ((:tipo_formapago = 2) and (vencimiento_nc >= fechahasta)) then
       total_nota_credito = :total_nota_credito + :importe_real;

    --Todos los comprobantes = TRANSFERENCIA
    if (:tipo_comprobante = 21) then --todo lo que no sea transferencia
      total_transferencia = :total_transferencia + :importe_real;
  end

  saldo = saldo_inicial + total_ingreso - total_egreso + :total_cta_cte_cliente - :total_cta_cte_proveedor - :total_nota_credito;

  suspend;
end^


ALTER PROCEDURE ESTADISTICA_VENTAS_POR_HORA (
    INTERVALO INTEGER,
    FECHA_DESDE DATE,
    FECHA_HASTA DATE,
    ID_SUCURSAL INTEGER)
RETURNS (
    HORA_DESDE TIME,
    HORA_HASTA TIME,
    CANTIDAD INTEGER,
    IMPORTE NUMERIC(15,4),
    HORA_PERIODO TIME,
    PERIODO INTEGER)
AS
declare variable desde timestamp;
declare variable hasta timestamp;
declare variable hora_apertura time;
declare variable hora_cierre time;
begin
  --obtengo la hora de apertura del negocio como base horaria para la estadistica
  select c.texto
  from configuracion_variables c
  where c.clave = 'horaAperturaNegocio'
  into :hora_apertura;

  --obtengo la hora de cierre del negocio como base horaria para la estadistica
  select c.texto
  from configuracion_variables c
  where c.clave = 'horaCierreNegocio'
  into :hora_cierre;

--  hora_apertura = '08:00:00';
--  hora_cierre = '23:59:00';

  desde = '2011-1-1 '||:hora_apertura;
  hasta = incdatetime(desde, 0, 0, 0, 0, :intervalo, 0);--hasta el incremento del intervalo
  hora_desde = cast(:desde as time);
  hora_hasta = cast(:hasta as time);
  hora_periodo = cast(incdatetime(desde, 0, 0, 0, 0, :intervalo/2, 0) as time);
  periodo = 1;
  while (:hora_desde < :hora_cierre) do
  begin
    select count(c.id_comprobante), sum(c.importe_venta)
    from comprobante c
    left join comprobante_detalle cd on (c.id_comprobante = cd.id_comprobante_detalle)
    where 1 = 1
      and c.id_tipo_cpb = 11 --facturas
      and cast(c.fecha_cobrada as time) between cast(:hora_desde as time) and cast(:hora_hasta as time) --en el rango horario
      and cast(c.fecha_cobrada as date) between :fecha_desde and :fecha_hasta --entre las fechas
      and ((c.id_sucursal = :id_sucursal) or (:id_sucursal = -1)) --de la sucursal
      and c.fecha_anulado is null --que no esten anulados
    into :cantidad, :importe;
    if (importe is null) then
      importe = 0;

    suspend;

    desde = :hasta;
    hasta = incdatetime(desde, 0, 0, 0, 0, :intervalo, 0);--hasta el incremento del intervalo
    if (extractday(:hasta) = 2) then
      hasta = '2011-1-1 23:59:59';--desde las 00 del 1/1/2011 (tomo dias para saber cuando se pasa de las 24)

    hora_desde = cast(:desde as time);
    hora_hasta = cast(:hasta as time);
    hora_periodo = cast(incdatetime(desde, 0, 0, 0, 0, :intervalo/2, 0) as time);
      periodo = periodo + 1;
  end
end^


ALTER PROCEDURE GENERAR_STOCK_INICIAL
AS
declare variable ID_SUCURSAL integer;
declare variable ID_PRODUCTO integer;
declare variable STOCK_MAX numeric(15,2);
declare variable STOCK_MIN numeric(15,2);
declare variable EXISTE_STOCK integer;
declare variable EXISTE_PRECIO integer;
declare variable SUCURSAL integer;
declare variable LLEVAR_STOCK varchar(1);
begin

  for select ts.id_sucursal
      from temp_sucursal ts
      into :id_sucursal
  do
  begin
    for select tp.id_producto, pr.stock_max, pr.stock_min,pr.llevar_stock
        from temp_producto tp
        left join producto pr on (tp.id_producto = pr.id_producto)
        into :id_producto, :stock_max, :stock_min, :llevar_stock
    do
    begin

     /* if (llevar_stock='S') then*/
       begin
          existe_stock = null;
          select s.id_stock_producto
          from stock_producto s
          where s.id_posicion_sucursal = :id_sucursal and
                s.id_producto = :id_producto
          into existe_stock;
    
          if (existe_stock is null) then
          begin
            insert into stock_producto (id_posicion_sucursal, id_producto, stock_actual, stock_min, stock_max,
                                        stock_repedido, stock_min_alarma)
            values (:id_sucursal, :id_producto, 0, :stock_min, :stock_max, :stock_min, null);
          end
    
          SELECT ps.ID_SUCURSAL
          FROM POSICION_SUCURSAL ps
          where ps.id_posicion_sucursal = :id_sucursal
          INTO :SUCURSAL;
    
          existe_precio = null;
    
          select pr.id_precio
          from precio pr
          where pr.id_sucursal = :SUCURSAL and
                pr.id_producto = :id_producto
          into existe_precio;
    
          if (existe_precio is null) then
          begin
            insert into precio (id_producto, id_sucursal)
            values (:id_producto, :sucursal);
          end
       end
    end
  end

  suspend;
exit;
end^


ALTER PROCEDURE INICIALIZAR_GENERADORES
RETURNS (
    TABLA VARCHAR(31),
    CAMPO_ID VARCHAR(31),
    GENERADOR VARCHAR(31),
    ID INTEGER)
AS
declare variable aux_string varchar(20);
declare variable id_suc integer;
declare variable max_id integer;
declare variable sentencia varchar(1000);
declare variable nro integer;
begin
  id_suc = null;
  select c.db_sucursal
  from configuracion c
  into :id_suc;
  if (id_suc is null) then
    exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA SUCURSAL, VERIFIQUE';

  for select r.rdb$field_name, r.rdb$relation_name, g.rdb$generator_name
  from rdb$relation_fields r
  left join rdb$generators g on ('GEN_' || trim(r.rdb$relation_name) || '_ID' = trim(g.rdb$generator_name))
  where r.rdb$system_flag = 0
    and r.rdb$field_id = 0
    and g.rdb$generator_name is not null
  into :campo_id, :tabla, :generador
  do
  begin
    campo_id = trim(:campo_id);
    tabla = trim(:tabla);
    generador = trim(:generador);

    sentencia = 'select max(a.'||:campo_id||') '||
                'from '||:tabla||' a '||
                'where a.'||:campo_id||' like '''||:id_suc||'%'' ;';
    execute statement sentencia into :max_id;

    if (:max_id is null) then
      max_id = 0;
    else
    begin
      aux_string = strreplace(''||:max_id, ''||:id_suc, '');
      if (:aux_string <> '') then
        max_id = cast(:aux_string as integer);
      else
        max_id = 0;
    end

    id = :max_id;
    sentencia = 'SET GENERATOR '||:generador||' TO '||:id||';';
    execute statement sentencia;

    suspend;
  end

end^


ALTER PROCEDURE INSERTAR_SALDO_INICIA_CTA_CTE (
    ID_CLIENTE INTEGER,
    ID_PROVEEDOR INTEGER,
    ID_SUCURSAL INTEGER,
    SALDO_INICIAL NUMERIC(15,2),
    FECHA TIMESTAMP)
AS
declare variable existe integer;
declare variable codigo_cpb integer;
declare variable id_comprobante integer;
begin
  id_comprobante = null;
  codigo_cpb = null;

  if (:id_cliente is not null) then --PARA LOS CLIENTES
  begin
    delete from comprobante c
    where c.id_cliente = :id_cliente
      and c.id_tipo_cpb = 17
      and c.id_sucursal = :id_sucursal;

    execute procedure sp_gen_comprobante_id
        returning_values :id_comprobante, :codigo_cpb;

    --inserto un comprobante del tipo OTRO EGRESOS con el cliente/proveedor y el y con el importe pasado como parametro
    insert into comprobante (id_comprobante, id_sucursal, id_proveedor, id_cliente, id_tipo_cpb, id_comp_estado, codigo,
                             fecha, observacion, base_imponible, saldo, importe_total, importe_venta)
    values (:id_comprobante, :id_sucursal, null, :id_cliente, 17, 0, lpad(:id_comprobante, 10, '0'), :fecha,
                                                                          'SALDO INICIAL CTA. CTE.', :saldo_inicial,
                                                                          :saldo_inicial, :saldo_inicial,
                                                                          :saldo_inicial);
  end

  if (:id_proveedor is not null) then --PARA LOS PROVEEDORES
  begin
    delete from comprobante c
    where c.id_proveedor = :id_proveedor
      and c.id_tipo_cpb = 16
      and c.id_sucursal = :id_sucursal;

    execute procedure sp_gen_comprobante_id
        returning_values :id_comprobante, :codigo_cpb;

    --inserto un comprobante del tipo OTRO EGRESOS con el cliente/proveedor y el y con el importe pasado como parametro
    insert into comprobante (id_comprobante, id_sucursal, id_proveedor, id_cliente, id_tipo_cpb, id_comp_estado, codigo,
                             fecha, fecha_cobrada, observacion, base_imponible, saldo, importe_total, importe_venta)
    values (:id_comprobante, :id_sucursal, :id_proveedor, null, 16, 0, lpad(:id_comprobante, 10, '0'), :fecha, :fecha,
                                                                            'SALDO INICIAL CTA. CTE.', :saldo_inicial,
                                                                            :saldo_inicial, :saldo_inicial,
                                                                            :saldo_inicial);
  end
end^


ALTER PROCEDURE MARCAR_PUNTO_SALIDA (
    ID_SUCURSAL INTEGER,
    ID_POSICION_SUCURSAL INTEGER)
AS
declare variable posicion integer;
begin

  for select ps.id_posicion_sucursal
  from posicion_sucursal ps
  where ps.id_sucursal = :id_sucursal
  into :posicion
  do
  begin
    if (:id_posicion_sucursal = :posicion) then
    begin
      update posicion_sucursal p
      set p.punto_salida = 'S'
      where p.id_posicion_sucursal = :posicion;
    end
    else
    begin
      update posicion_sucursal p
      set p.punto_salida = 'N'
      where p.id_posicion_sucursal = :posicion;
    end
  end

end^


ALTER PROCEDURE NOTA_PEDIDO_UPDATE_ESTADO (
    ID_COMPROBANTE INTEGER,
    ID_ESTADO INTEGER)
AS
declare variable idcomprobante integer;
begin
    idcomprobante = null;

    select first 1 c.id_comprobante
    from comprobante c
    inner join comprobante_detalle cd on (c.id_comprobante = cd.id_comprobante)
    where (cd.cantidad_recibida <> cd.cantidad_almacenada)
      and (c.id_comprobante = :ID_COMPROBANTE)
    into :idcomprobante;

    if (idcomprobante is null) then
    begin
      update comprobante
      set id_comp_estado = :id_estado --actualizo el estado de la nota de pedido
      where (id_comprobante = :id_comprobante);
    end

    suspend;
end^


ALTER PROCEDURE ORDEN_PAGO_CTA_CTE_ANULAR (
    ID_COMPROBANE INTEGER)
AS
declare variable id_factura integer;
declare variable importe_restaurar numeric(15,2);
begin

  for select cfp.id_comprobante, sum(cfp.importe_real)
  from comprobante_forma_pago cfp
  where cfp.id_recibo_op = :id_comprobane
    and cfp.cuenta_egreso <> 1
  group by cfp.id_comprobante
  into :id_factura, :importe_restaurar
  do
  begin
    update comprobante_forma_pago fp --actualizo la forma de pago cuenta corriente de la factura
    set fp.importe = fp.importe + :importe_restaurar,
        fp.importe_real = fp.importe_real + :importe_restaurar
    where fp.id_comprobante = :id_factura
      and fp.cuenta_egreso = 1;
  end

  delete from comprobante_forma_pago cfp
  where cfp.id_recibo_op = :id_comprobane
    and cfp.cuenta_egreso <> 1;

end^


ALTER PROCEDURE ORDEN_PAGO_CTA_CTE_CONFIRMAR (
    ID_COMPROBANTE INTEGER)
AS
declare variable id_cuenta integer;
declare variable id_tipo_fpago integer;
declare variable importe_fpago numeric(15,2);
declare variable importe_cancelar numeric(15,2);
declare variable restante numeric(15,2);
declare variable id_factura integer;
declare variable mdcp_fecha date;
declare variable mdcp_banco varchar(50);
declare variable mdcp_cheque varchar(50);
declare variable fecha_fp timestamp;
declare variable id_ultimo_pago integer;
declare variable id_pago_facturas integer;
declare variable saldo_cta_cte numeric(15,2);
begin
  select first 1 pf.id_pago_facturas
  from pago_facturas pf
  left join comprobante cp on (pf.id_factura = cp.id_comprobante)
  where cp.id_comp_estado = 3
    and pf.id_comprobante = :id_comprobante
  into :id_factura;
  if (id_factura is not null) then
     exception error 'No se puede confirmar la Orden de Pago, hay una Factura Anulada, Verifique';

  id_ultimo_pago= -1; --el ultimo pago es -1 para que no descarte ninguno al inicio

  --agrupo las formas de pago de la OP por cuenta de ingreso y forma de pago y recorro cada una de ellas
  for select cf.cuenta_egreso, cf.id_tipo_formapag, cf.mdcp_fecha, cf.mdcp_banco, cf.mdcp_cheque, cf.fecha_fp, sum(cf.importe_real)
  from comprobante_forma_pago cf
  where cf.id_comprobante = :id_comprobante
  group by cf.cuenta_egreso, cf.id_tipo_formapag, cf.mdcp_fecha, cf.mdcp_banco, cf.mdcp_cheque, cf.fecha_fp
  into :id_cuenta, :id_tipo_fpago, :mdcp_fecha, :mdcp_banco, :mdcp_cheque, :fecha_fp, :importe_fpago
  do
  begin
    restante = :importe_fpago; --inicialmente el restante a pagar de cada forma de pago es el importe total

    --recorro todas las facturas a cancelar y obtengo el importe que se cancela
    for select pf.id_pago_facturas, pf.id_factura, pf.importe
    from pago_facturas pf
    where pf.id_comprobante = :id_comprobante
      and pf.id_pago_facturas > :id_ultimo_pago --con esto verifico que no empiece siempre con la primera, sino que descarta las que ya se pagaron
    order by pf.id_pago_facturas
    into :id_pago_facturas, :id_factura, :importe_cancelar
    do
    begin
      --obtengo el saldo actual del comprobante
      select cfp.importe_real
      from comprobante_forma_pago cfp
      where cfp.id_comprobante = :id_factura
        and cfp.cuenta_egreso = 1
      into :saldo_cta_cte;
      if (:saldo_cta_cte = 0) then --si es cero, entonce paso a la siguiente
        id_ultimo_pago = :id_factura;
      else
      if (:importe_cancelar > :saldo_cta_cte) then --si lo que tengo que cancelar es mayor al saldo del comprobante
        importe_cancelar = :saldo_cta_cte; --entonce cancelo el comprobante completo

      if ((:restante <> 0) and (:saldo_cta_cte <> 0))then --mientras quede algo por pagar
      begin
        if (:restante <= :importe_cancelar) then --si el monto a pagar con una forma de pago dada es menor al importe a cancelar en la factura
        begin
          insert into comprobante_forma_pago (id_comprobante, id_tipo_formapag,  mdcp_fecha,  mdcp_banco,  mdcp_cheque,   importe,  cuenta_egreso,  fecha_fp, importe_real, id_recibo_op)
                                      values (:id_factura   ,   :id_tipo_fpago, :mdcp_fecha, :mdcp_banco, :mdcp_cheque, :restante,     :id_cuenta, :fecha_fp, :restante, :id_comprobante);

          update comprobante_forma_pago fp --actualizo la forma de pago cuenta corriente de la factura
          set fp.importe = fp.importe - :restante,
              fp.importe_real = fp.importe_real - :restante
          where fp.id_comprobante = :id_factura
            and fp.cuenta_egreso = 1;

          restante = 0; --actualizo el restante, pongo que no puedo pagar mas nada con esta forma de pago
        end
        else --si el monto a pagar con una forma de pago dada es mayor al importe a cancelar en la factura
        begin
          --cancelo la factura completa
          insert into comprobante_forma_pago (id_comprobante, id_tipo_formapag,  mdcp_fecha,  mdcp_banco,  mdcp_cheque,           importe,  cuenta_egreso,  fecha_fp, importe_real, id_recibo_op)
                                      values (:id_factura   ,   :id_tipo_fpago, :mdcp_fecha, :mdcp_banco, :mdcp_cheque, :importe_cancelar,     :id_cuenta, :fecha_fp, :importe_cancelar, :id_comprobante);

          update comprobante_forma_pago fp --actualizo la forma de pago cuenta corriente de la factura
          set fp.importe = 0,
              fp.importe_real = 0
          where fp.id_comprobante = :id_factura
            and fp.cuenta_egreso = 1;

          restante = :restante - :importe_cancelar; --actualizo el restante
        end
      end
    end
  end

  suspend;
end^


ALTER PROCEDURE PROCESAR_STOCK (
    ID_STOCK_PROD INTEGER,
    ID_PRODUCTO INTEGER,
    ID_POS_SUC INTEGER,
    CANTIDAD_ALMACENAR FLOAT,
    STOCK_MIN FLOAT,
    STOCK_MAX FLOAT,
    STOCK_REPEDIDO FLOAT,
    ID_COMPROBANTE INTEGER)
AS
declare variable ID_STOCK_PRODUCTO integer;
declare variable ID_STOCK_PRODUCTO_ORIGEN integer;
declare variable LLEVAR_STOCK varchar(1);
begin
  llevar_stock='N';

  select first 1 p.llevar_stock
  from stock_producto sp3
  left join producto p on (p.id_producto=sp3.id_producto)
  where ((sp3.id_stock_producto=:id_stock_prod)or(p.id_producto=:id_producto))
  into :llevar_stock;


  -- Descuento el stock Acutal de origen----------------------------
  if ((id_stock_prod is not null)and(:llevar_stock='S')) then
  begin

    id_stock_producto_origen = null;

    select id_stock_producto
    from stock_producto sp
    where (sp.id_stock_producto = :id_stock_prod)
    into :id_stock_producto_origen;

    if (:id_stock_producto_origen is not null) then
    begin
      update stock_producto sp
      set sp.stock_actual = sp.stock_actual - :cantidad_almacenar
      where (sp.id_stock_producto = :id_stock_prod);
    end
  end

---PARA LAS TRANSFERENCIAS ENTRE SUCURSALES----------------------
-- Aumento el stock Acutal de destino----------------------------
  if ((id_producto is not null) and (id_pos_suc is not null)and(:llevar_stock='S')) then
  begin
    id_stock_producto = null;  --busco el id_stock
    select id_stock_producto   --para el producto en la sucursal de destino
    from stock_producto sp
    where (sp.id_producto = :id_producto)
      and (sp.id_posicion_sucursal = :id_pos_suc)
    into :id_stock_producto;

    if (:id_stock_producto is null) then --si el id_stock no existe lo agrego con la cantidad
    begin
      insert into stock_producto (id_producto, stock_actual, stock_min, stock_max, stock_repedido, id_posicion_sucursal)
      values (:id_producto, :cantidad_almacenar, :stock_min, :stock_max, :stock_repedido, :id_pos_suc);
    end
    else
    begin  --si existe actualizo la cantidad de stock
      update stock_producto sp
      set sp.stock_actual = stock_actual + :cantidad_almacenar
      where (sp.id_producto = :id_producto)
        and (sp.id_posicion_sucursal = :id_pos_suc);
    end

    if (id_comprobante is not null) then
    begin
      update comprobante_detalle cd
      set cd.cantidad_almacenada = cantidad_almacenada + :cantidad_almacenar
      where (cd.id_comprobante = :id_comprobante)
        and (cd.id_producto = :id_producto);
    end

  end
  --------------------------------------------------------------------

  suspend;
end^


ALTER PROCEDURE RECIBO_CTA_CTE_ANULAR (
    ID_COMPROBANE INTEGER)
AS
declare variable id_factura integer;
declare variable importe_restaurar numeric(15,2);
begin

  for select cfp.id_comprobante, sum(cfp.importe_real)
  from comprobante_forma_pago cfp
  where cfp.id_recibo_op = :id_comprobane
    and cfp.cuenta_ingreso <> 1
  group by cfp.id_comprobante
  into :id_factura, :importe_restaurar
  do
  begin
    update comprobante_forma_pago fp --actualizo la forma de pago cuenta corriente de la factura
    set fp.importe = fp.importe + :importe_restaurar,
        fp.importe_real = fp.importe_real + :importe_restaurar
    where fp.id_comprobante = :id_factura
      and fp.cuenta_ingreso = 1;
  end

  delete from comprobante_forma_pago cfp
  where cfp.id_recibo_op = :id_comprobane
    and cfp.cuenta_ingreso <> 1;

end^


ALTER PROCEDURE RECIBO_CTA_CTE_CONFIRMAR (
    ID_COMPROBANTE INTEGER)
AS
declare variable id_cuenta integer;
declare variable id_tipo_fpago integer;
declare variable importe_fpago numeric(15,2);
declare variable importe_cancelar numeric(15,2);
declare variable restante numeric(15,2);
declare variable id_factura integer;
declare variable mdcp_fecha date;
declare variable mdcp_banco varchar(50);
declare variable mdcp_cheque varchar(50);
declare variable fecha_fp timestamp;
declare variable id_ultimo_pago integer;
declare variable id_pago_facturas integer;
declare variable saldo_cta_cte numeric(15,2);
begin
  select first 1 pf.id_pago_facturas
  from pago_facturas pf
  left join comprobante cp on (pf.id_factura = cp.id_comprobante)
  where cp.id_comp_estado = 3
    and pf.id_comprobante = :id_comprobante
  into :id_factura;
  if (id_factura is not null) then
     exception error 'No se puede confirmar el Recibo, hay una Factura Anulada, Verifique';

  id_ultimo_pago= -1; --el ultimo pago es -1 para que no descarte ninguno al inicio

  --agrupo las formas de pago del RECIBO por cuenta de ingreso y forma de pago y recorro cada una de ellas
  for select cf.cuenta_ingreso, cf.id_tipo_formapag, cf.mdcp_fecha, cf.mdcp_banco, cf.mdcp_cheque, cf.fecha_fp, sum(cf.importe_real)
  from comprobante_forma_pago cf
  where cf.id_comprobante = :id_comprobante
  group by cf.cuenta_ingreso, cf.id_tipo_formapag, cf.mdcp_fecha, cf.mdcp_banco, cf.mdcp_cheque, cf.fecha_fp
  into :id_cuenta, :id_tipo_fpago, :mdcp_fecha, :mdcp_banco, :mdcp_cheque, :fecha_fp, :importe_fpago
  do
  begin
    restante = :importe_fpago; --inicialmente el restante a pagar de cada forma de pago es el importe total

    --recorro todas las facturas a cancelar y obtengo el importe que se cancela
    for select pf.id_pago_facturas, pf.id_factura, pf.importe
    from pago_facturas pf
    where pf.id_comprobante = :id_comprobante
      and pf.id_pago_facturas > :id_ultimo_pago --con esto verifico que no empiece siempre con la primera, sino que descarta las que ya se pagaron
    order by pf.id_pago_facturas
    into :id_pago_facturas, :id_factura, :importe_cancelar
    do
    begin
      --obtengo el saldo actual del comprobante
      select cfp.importe_real
      from comprobante_forma_pago cfp
      where cfp.id_comprobante = :id_factura
        and cfp.cuenta_ingreso = 1
      into :saldo_cta_cte;
      if (:saldo_cta_cte = 0) then --si es cero, entonce paso a la siguiente
        id_ultimo_pago = :id_factura;
      else
      if (:importe_cancelar > :saldo_cta_cte) then --si lo que tengo que cancelar es mayor al saldo del comprobante
        importe_cancelar = :saldo_cta_cte; --entonce cancelo el comprobante completo

      if ((:restante <> 0) and (:saldo_cta_cte <> 0))then --mientras quede algo por pagar
      begin
        if (:restante <= :importe_cancelar) then --si el monto a pagar con una forma de pago dada es menor al importe a cancelar en la factura
        begin
          insert into comprobante_forma_pago (id_comprobante, id_tipo_formapag,  mdcp_fecha,  mdcp_banco,  mdcp_cheque,   importe,  cuenta_ingreso,  fecha_fp, importe_real, id_recibo_op)
                                      values (:id_factura   ,   :id_tipo_fpago, :mdcp_fecha, :mdcp_banco, :mdcp_cheque, :restante,      :id_cuenta, :fecha_fp, :restante, :id_comprobante);

          update comprobante_forma_pago fp --actualizo la forma de pago cuenta corriente de la factura
          set fp.importe = fp.importe - :restante,
              fp.importe_real = fp.importe_real - :restante
          where fp.id_comprobante = :id_factura
            and fp.cuenta_ingreso = 1;

          restante = 0; --actualizo el restante, pongo que no puedo pagar mas nada con esta forma de pago
        end
        else --si el monto a pagar con una forma de pago dada es mayor al importe a cancelar en la factura
        begin
          --cancelo la factura completa
          insert into comprobante_forma_pago (id_comprobante, id_tipo_formapag,  mdcp_fecha,  mdcp_banco,  mdcp_cheque,           importe,  cuenta_ingreso,  fecha_fp, importe_real, id_recibo_op)
                                      values (:id_factura   ,   :id_tipo_fpago, :mdcp_fecha, :mdcp_banco, :mdcp_cheque, :importe_cancelar,      :id_cuenta, :fecha_fp, :importe_cancelar, :id_comprobante);

          update comprobante_forma_pago fp --actualizo la forma de pago cuenta corriente de la factura
          set fp.importe = 0,
              fp.importe_real = 0
          where fp.id_comprobante = :id_factura
            and fp.cuenta_ingreso = 1;

          restante = :restante - :importe_cancelar; --actualizo el restante
        end
      end
    end
  end

  suspend;
end^


ALTER PROCEDURE SALDOS_CUENTAS (
    ID_SUCURSAL INTEGER,
    FECHA_HASTA DATE)
RETURNS (
    ID_CUENTA INTEGER,
    CODIGO VARCHAR(10),
    NOMBRE_CUENTA VARCHAR(50),
    NRO_CTA_BANCO VARCHAR(10),
    IMPORTE NUMERIC(15,4))
AS
declare variable grupo integer;
begin
  --VER COMO CALCULAR EL SALDO DE LA CUENTA CORRIENTE, EN PRINCIPIO SERIA
  --LA SUMATORIA DE TODOS LOS SALDOS DE LOS COMPROBANTES.

   for select sal.id_cuenta, cta.codigo, cta.nombre_cuenta, cta.nro_cta_bancaria, sal.grupo, sum(importe)
   from calc_saldos_cuentas(:fecha_hasta) sal
   left join cuenta cta on (cta.id_cuenta = sal.id_cuenta)
   where ((sal.id_sucursal = :id_sucursal) or (:id_sucursal = -1) ) --si id_sucursal es -1 trae de todas las sucursales
   group by sal.id_cuenta, cta.nombre_cuenta, cta.nro_cta_bancaria, cta.codigo, sal.grupo
   into :id_cuenta, :codigo, :nombre_cuenta, :nro_cta_banco, :grupo, :importe
   do
   begin
     if (grupo = 2) then
        nombre_cuenta = :nombre_cuenta||' CLIENTE';
     else
     if (grupo = 3) then
        nombre_cuenta = :nombre_cuenta||' PROVEEDOR';
        
     suspend;
   end


end^


ALTER PROCEDURE SP_GEN_COLOR_ID
RETURNS (
    ID INTEGER)
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_color_id,1);

  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_GEN_COMPROBANTE_ID
RETURNS (
    ID INTEGER,
    CODIGO VARCHAR(30))
AS
declare variable ID_SUCURSAL integer;
declare variable CLAVE varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(GEN_COMPROBANTE_ID,1);
  codigo=lpad(clave,10,'0');
  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_GEN_EMPRESA_ID
RETURNS (
    ID INTEGER)
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_empresa_id,1);

  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_GEN_MAIL_MENSAJE_ID
RETURNS (
    ID INTEGER)
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_mail_mensaje_id,1);

  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_GEN_PERSONA_ID
RETURNS (
    ID INTEGER)
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_persona_id,1);

  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_GEN_PRODUCTO_CABECERA_ID
RETURNS (
    ID INTEGER)
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_producto_cabecera_id,1);

  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_GEN_PRODUCTO_ID
RETURNS (
    ID INTEGER)
AS
declare variable id_sucursal integer;
declare variable clave varchar(30);
BEGIN
  id_sucursal = null;
  select c.db_sucursal
  from configuracion c
  into :id_sucursal;
  if (id_sucursal is null) then
     exception error 'LA BASE DE DATOS NO TIENE ASOCIADA UNA sucursal, VERIFIQUE';

  clave = id_sucursal||GEN_ID(gen_producto_id,1);

  ID = clave;
  SUSPEND;
END^


ALTER PROCEDURE SP_IMPRIMIR_ETIQUETAS (
    DESDE_RENGLON INTEGER,
    LONG_DESCRIPCION INTEGER)
RETURNS (
    CODIGOBARRA VARCHAR(20),
    ID_PRODUCTO INTEGER,
    DESCRIPCION VARCHAR(200),
    ID_PRECIO INTEGER,
    MEDIDA VARCHAR(30),
    COLOR VARCHAR(30),
    PRECIO NUMERIC(15,2),
    NOMBRE_PRO VARCHAR(100))
AS
declare variable cantidad integer;
declare variable x integer;
begin
  id_producto = 0;
  descripcion = '';
  codigobarra = '';

  for select ie.id_producto, ie.id_precio, pc.nombre, ie.cantidad, p.codigo_barra, me.medida,
             co.nombre as color, pr.precio_venta, substr(pc.nombre || ' - M:' || me.medida || ' - C:' || co.nombre, 0, :long_descripcion)
  from imprimir_etiquetas ie
  left join producto p on ie.id_producto = p.id_producto
  left join precio pr on ie.id_precio = pr.id_precio
  left join medida me on p.id_medida = me.id_medida
  left join producto_cabecera pc on (p.id_prod_cabecera = pc.id_prod_cabecera)
  left join color co on (pc.color = co.id_color)
  into :id_producto, :id_precio, :nombre_pro, :cantidad, :codigobarra, :medida,
       :color, :precio, :descripcion
  do
  begin
    x = 1;
    while (x <= cantidad) do
    begin
      suspend;
      x = x + 1;
    end
  end
end^


ALTER PROCEDURE VACIAR_AUDITORIA (
    USUARIO VARCHAR(67),
    FECHA TIMESTAMP,
    OPERACION VARCHAR(1),
    TABLA VARCHAR(67),
    NO_FECHA VARCHAR(1),
    NO_USUARIO VARCHAR(1),
    NO_OPERACION VARCHAR(1),
    NO_TABLA VARCHAR(1))
AS
declare variable id integer;
begin
/*$$IBEC$$   for select t.id
  from ibe$log_tables t
  where ((cast(t.date_time as date) = :fecha) or (:no_fecha = 'S'))
    and ((t.user_name = :usuario) or (:no_usuario = 'S'))
    and ((t.operation = :operacion) or (:no_operacion = 'S'))
    and ((t.table_name = :tabla) or (:no_tabla = 'S'))
  into :id
  do
  begin
    delete from ibe$log_blob_fields b
    where b.log_tables_id = :id;

    delete from ibe$log_fields f
    where f.log_tables_id = :id;

    delete from ibe$log_keys k
    where k.log_tables_id = :id;
  end

  delete from ibe$log_tables t
  where ((cast(t.date_time as date) = :fecha) or (:no_fecha = 'S'))
    and ((t.user_name = :usuario) or (:no_usuario = 'S'))
    and ((t.operation = :operacion) or (:no_operacion = 'S'))
    and ((t.table_name = :tabla) or (:no_tabla = 'S')); $$IBEC$$*/

end^


ALTER PROCEDURE VALIDAR_DEMO_SISTEMA
RETURNS (
    RESULTADO INTEGER)
AS
declare variable clave varchar(100);
declare variable fecha_limite date;
declare variable texto varchar(100);
begin
  resultado = 0;

  select c.clave, c.fecha, c.texto
  from configuracion_variables c
  where c.clave = 'demoSistema'
  into :clave, :fecha_limite, :texto;

  if (clave is not null) then --si existe la variable
  begin
    if (:fecha_limite < cast(current_date as date)) then
    begin
      update configuracion_variables v
      set v.texto = 'SI'
      where v.clave = 'demoSistema';

      texto = 'SI';
    end

    if (:texto = 'SI') then
       resultado = 1;
  end

  suspend;
end^


ALTER PROCEDURE VER_AUDITORIA_TABLA (
    ID_TABLA INTEGER)
RETURNS (
    CAMPO VARCHAR(67),
    VALOR_NUEVO VARCHAR(255),
    VALOR_VIEJO VARCHAR(255),
    VALOR_REF_NUEVO VARCHAR(255),
    VALOR_REF_VIEJO VARCHAR(255))
AS
declare variable tabla varchar(67);
begin /*$$IBE$$ 
     
  select t.table_name
  from ibe$log_tables t
  where t.id = :id_tabla
  into :tabla;

  for select f.field_name, f.old_value, f.new_value
  from ibe$log_fields f
  where f.log_tables_id = :id_tabla
  into :campo, :valor_viejo, :valor_nuevo
  do
  begin
       valor_ref_nuevo = null;
       valor_ref_viejo = null;

 $$IBE$$*/ /******************************************************************************/
/*                        TABLA DE PROVEEDORES                                */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_PROVEEDOR') then
    begin
         if (:campo = 'ID_PROVINCIA') then
         begin
            select p.nombre
            from adm_provincia p
            where p.id_provincia = :valor_viejo
            into :valor_ref_viejo;

            select p.nombre
            from adm_provincia p
            where p.id_provincia = :valor_nuevo
            into :valor_ref_nuevo;
         end

         if (:campo = 'ID_IVA') then
         begin
            select i.condicion
            from adm_iva i
            where i.id_iva = :valor_viejo
            into :valor_ref_viejo;

            select i.condicion
            from adm_iva i
            where i.id_iva = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE RECIBOS                                    */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_RECIBOS') then
    begin
         if (:campo = 'ID_ORIGEN') then
         begin
            select r.nombre_origen
            from adm_recibos_origen r
            where r.id_origen = :valor_viejo
            into :valor_ref_viejo;

            select r.nombre_origen
            from adm_recibos_origen r
            where r.id_origen = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end


 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE COMPROBANTES                                */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_COMPRA_CPB') then
    begin
         if (:campo = 'ID_PROVEEDOR') then
         begin
            select p.apellido_y_nombre
            from adm_proveedor p
            where p.id_proveedor = :valor_viejo
            into :valor_ref_viejo;

            select p.apellido_y_nombre
            from adm_proveedor p
            where p.id_proveedor = :valor_nuevo
            into :valor_ref_nuevo;
         end

         if (:campo = 'ID_TIPO_CPB') then
         begin
            select t.descripcion
            from adm_tipo_cpb t
            where t.id_tipo_cpb = :valor_viejo
            into :valor_ref_viejo;

            select t.descripcion
            from adm_tipo_cpb t
            where t.id_tipo_cpb = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE ORDEN PAGO                                 */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_ORDENDEPAGO') then
    begin
         if (:campo = 'ID_PROVEEDOR') then
         begin
            select p.apellido_y_nombre
            from adm_proveedor p
            where p.id_proveedor = :valor_viejo
            into :valor_ref_viejo;

            select p.apellido_y_nombre
            from adm_proveedor p
            where p.id_proveedor = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE DESTINOS                                   */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_DESTINO') then
    begin
         if (:campo = 'ID_TIPO_DESTINO') then
         begin
            select t.descripcion
            from adm_tipo_destino t
            where t.id_tipo_destino = :valor_viejo
            into :valor_ref_viejo;

            select t.descripcion
            from adm_tipo_destino t
            where t.id_tipo_destino = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end


 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE PRESUPUESTOS                               */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_PRESUPUESTO') then
    begin
         if (:campo = 'ID_PLAN_CUENTA') then
         begin
            select p.nombre
            from adm_plan_cuenta p
            where p.id_plan_cuenta = :valor_viejo
            into :valor_ref_viejo;

            select p.nombre
            from adm_plan_cuenta p
            where p.id_plan_cuenta = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE CUENTAS MOVIMIENTOS                        */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_CUENTAS_MOVIMIENTOS') then
    begin
         if (:campo = 'ID_CUENTA_INGRESO') then
         begin
            select c.nombre_cuenta
            from adm_cuentas c
            where c.id_cuenta = :valor_viejo
            into :valor_ref_viejo;

            select c.nombre_cuenta
            from adm_cuentas c
            where c.id_cuenta = :valor_nuevo
            into :valor_ref_nuevo;
         end

         if (:campo = 'ID_CUENTA_EGRESO') then
         begin
            select c.nombre_cuenta
            from adm_cuentas c
            where c.id_cuenta = :valor_viejo
            into :valor_ref_viejo;

            select c.nombre_cuenta
            from adm_cuentas c
            where c.id_cuenta = :valor_nuevo
            into :valor_ref_nuevo;
         end

         if (:campo = 'ID_MEDIO') then
         begin
            select m.nombre_medio_cobro_pago
            from adm_medios_cobro_pago m
            where m.id_medio = :valor_viejo
            into :valor_ref_viejo;

            select m.nombre_medio_cobro_pago
            from adm_medios_cobro_pago m
            where m.id_medio = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE RECIBOS CUENTAS                            */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_RECIBOS_CUENTAS') then
    begin
         if (:campo = 'ID_PRESUPUESTO') then
         begin
            select pc.nombre
            from adm_presupuesto p
            left join adm_plan_cuenta pc on (p.id_plan_cuenta = pc.id_plan_cuenta)
            where p.id_presupuesto = :valor_viejo
            into :valor_ref_viejo;

            select pc.nombre
            from adm_presupuesto p
            left join adm_plan_cuenta pc on (p.id_plan_cuenta = pc.id_plan_cuenta)
            where p.id_presupuesto = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE COMPROBANTES CUENTAS                       */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_CPB_CUENTAS') then
    begin
         if (:campo = 'ID_PRESUPUESTO') then
         begin
            select pc.nombre
            from adm_presupuesto p
            left join adm_plan_cuenta pc on (p.id_plan_cuenta = pc.id_plan_cuenta)
            where p.id_presupuesto = :valor_viejo
            into :valor_ref_viejo;

            select pc.nombre
            from adm_presupuesto p
            left join adm_plan_cuenta pc on (p.id_plan_cuenta = pc.id_plan_cuenta)
            where p.id_presupuesto = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end

 $$IBEC$$*//******************************************************************************/
/*                        TABLA DE COMPROBANTES DESTINOS                      */
/******************************************************************************//*$$IBEC$$ 
    if (:tabla = 'ADM_CPB_DESTINOS') then
    begin
         if (:campo = 'ID_DESTINO') then
         begin
            select d.descripcion
            from adm_destino d
            where d.id_destino = :valor_viejo
            into :valor_ref_viejo;

            select d.descripcion
            from adm_destino d
            where d.id_destino = :valor_nuevo
            into :valor_ref_nuevo;
         end
    end $$IBEC$$*/ /*$$IBE$$ 

                                                                                               
    suspend;
  end

 $$IBE$$*/ SUSPEND;
end^


ALTER PROCEDURE VER_DESTINO_COMPROBANTE (
    ID_PERSONA INTEGER,
    ID_EMPRESA INTEGER)
RETURNS (
    NOMBRE VARCHAR(200),
    DIRECCION VARCHAR(200),
    CODIGO_POSTAL VARCHAR(20),
    LOCALIDAD VARCHAR(200),
    PROVINCIA VARCHAR(50),
    TIPO_DOCUMENTO VARCHAR(20),
    NUMERO_DOCUMENTO VARCHAR(50),
    TIPO_IVA VARCHAR(50),
    CUIT_CUIL VARCHAR(30))
AS
begin

  if (:id_empresa is null) then
  begin
       select pe.nombre, pe.direccion, pe.codigo_postal, pe.localidad, pr.nombre_provincia,
              td.nombre_tipo_doc, pe.numero_doc, ti.nombre_tipo_iva, pe.cuit_cuil
       from persona pe
       left join tipo_documento td on (pe.id_tipo_doc = td.id_tipo_doc)
       left join tipo_iva ti on (pe.id_tipo_iva = ti.id_tipo_iva)
       left join provincia pr on (pe.id_provincia = pr.id_provincia)
       where pe.id_persona = :id_persona
       into :nombre, :direccion, :codigo_postal, :localidad, :provincia,
            :tipo_documento, :numero_documento, :tipo_iva, :cuit_cuil;

  end

  if (:id_persona is null) then
  begin
       tipo_documento = null;
       numero_documento = null;

       select em.nombre, em.direccion, em.codigo_postal, em.localidad, pr.nombre_provincia,
              ti.nombre_tipo_iva, em.cuit_cuil
       from empresa em
       left join tipo_iva ti on (em.id_tipo_iva = ti.id_tipo_iva)
       left join provincia pr on (em.id_provincia = pr.id_provincia)
       where em.id_empresa = :id_empresa
       into :nombre, :direccion, :codigo_postal, :localidad, :provincia,
            :tipo_iva, :cuit_cuil;
  end

  suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                                 Roles                                  ***/
/******************************************************************************/

CREATE ROLE BASE;


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE CALC_SALDOS_CUENTAS
'Procedimiento para calcular el saldo de cada una de las cuentas
al dia pasado como parametro, ademas del saldo total
para last CTA CTE CLIENTE, CTA CTE PROVEEDOR y NOTA CREDITO';

DESCRIBE PROCEDURE ESTADISTICA_DETALLE_MOVIMIENTOS
'Estadistica que refleja los todos los movimientos de INGRESO,
EGRESO y TRANSFERENCIAS realizados entre un rango de fecha
Comprobantes q detalla: FACTURA, FACTURA_COMPRA, DEVOLUCION,
OTROS_INGRESOS, OTROS_EGRESOS, ORDEN_PAGO, RECIBO, TRANSEFERENCIA';

DESCRIBE PROCEDURE ESTADISTICA_DIARIA_GLOBAL
'Estadistica que refleja diariamente el resumen de ingresos, egresos y saldos
entre un rango de fecha dado.
Comprobantes q se toman en cuenta: FACTURA, FACTURA_COMPRA, DEVOLUCION,
OTROS_INGRESOS, OTROS_EGRESOS, ORDEN_PAGO, RECIBO';

DESCRIBE PROCEDURE ESTADISTICA_DIARIA_MOV_INTERNOS
'Estadistica que refleja diariamente el resumen de ingresos, egresos y saldos
entre un rango de fecha dado.
Comprobantes q se toman en cuenta: OTROS_INGRESOS y OTROS_EGRESOS';

DESCRIBE PROCEDURE ESTADISTICA_IE_MEDIO
'Estadistica que refleja los totales de cada forma de pago utilizada
entre un rango de fecha dado.
Comprobantes q se toman en cuenta: FACTURA, FACTURA_COMPRA, DEVOLUCION,
OTROS_INGRESOS, OTROS_EGRESOS, ORDEN_PAGO, RECIBO';



/******************************************************************************/
/***                          Fields descriptions                           ***/
/******************************************************************************/

DESCRIBE FIELD FECHA_COBRADA TABLE COMPROBANTE
'Fecha cuando se cancela totalmente la factura';

DESCRIBE FIELD FECHA_ENVIADA TABLE COMPROBANTE
'Fecha cuando se envio la factura';

DESCRIBE FIELD CANTIDAD_RECIBIDA TABLE COMPROBANTE_DETALLE
'Para tipos comprobante NOTA DE PEDIDO. Indica cuanto recibimos realmente
del producto que pedimos.';

DESCRIBE FIELD CANTIDAD_ALMACENADA TABLE COMPROBANTE_DETALLE
'Para tipos comprobante NOTA DE PEDIDO. Indica la cantidad de productos
que aun no se han almacenado en los depositos.';

DESCRIBE FIELD DB_SUCURSAL TABLE CONFIGURACION
'Numero de dos digitos unico para cada sucursal para generar los id de cada una
de las tablas.';

DESCRIBE FIELD ID_SUCURSAL TABLE CONFIGURACION
'Guardo el id de la sucursal al cual pertenece la base de datos
(SE OBTIENE DE LA TABLA SUCURSAL)';

DESCRIBE FIELD ULTIMA_FECHA TABLE CONFIGURACION
'guardo la ultima fecha en la que se ingreso al sistema correctamente
para llevar un control y no se ingrese con fecha erronea';

DESCRIBE FIELD ID_PERSONA TABLE CUENTA_CORRIENTE
'Id de la persona cuando es un cliente, sino null.';

DESCRIBE FIELD ID_PROVEEDOR TABLE CUENTA_CORRIENTE
'Id de la empresa cuando es un proveedor, sino null.';

DESCRIBE FIELD LIMITE_DEUDA TABLE CUENTA_CORRIENTE
'Credito para realizar compras';

DESCRIBE FIELD VENCIMIENTO_DIAS TABLE CUENTA_CORRIENTE
'Cantidad de dias para tomar una factura como atrasada o no';

DESCRIBE FIELD CUENTA_PRINCIPAL TABLE MAIL_CUENTAS
'Si es ''S'' Es la cuenta principal de la sucursal q se va a acargar
cuando se inicia el sistema.
Tiene q haber solo una cuenta principal por cada sucursal.';

DESCRIBE FIELD CABECERA_PARA TABLE MAIL_MENSAJE
'A quien esta dirigido el mail';

DESCRIBE FIELD CABECERA_CC TABLE MAIL_MENSAJE
'a quien se le envian copias';

DESCRIBE FIELD CABECERA_CCO TABLE MAIL_MENSAJE
'a quien se le envian copias oculta';

DESCRIBE FIELD CABECERA_ASUNTO TABLE MAIL_MENSAJE
'Asunto del mail';

DESCRIBE FIELD CABECERA_PRIORIDAD TABLE MAIL_MENSAJE
'Prioridad del mail';

DESCRIBE FIELD CABECERA_ACUSE_RECIBO TABLE MAIL_MENSAJE
'Si se envio con acuse de recubo ''S'' sino ''N''';

DESCRIBE FIELD ENVIADO TABLE MAIL_MENSAJE
'Indica si el mail se pudo enviar o no';

DESCRIBE FIELD TIPO TABLE MAIL_MENSAJE
'''S'' indica mail de salida
''E'' indica mail de entrada';

DESCRIBE FIELD ID_COMPROBANTE TABLE PAGO_FACTURAS
'ID del comprobante, puede ser el id del RECIBO o de la ORDEN PAGO';

DESCRIBE FIELD ID_FACTURA TABLE PAGO_FACTURAS
'ID de la factura que voy a cancelar ya sea de COMPRA (para la ORDEN PAGO) o VENTA (para el RECIBO)';

DESCRIBE FIELD ID_TIPO_COMPROBANTE TABLE PAGO_FACTURAS
'ID del tipo de comprobante que origina el registro (OP o RECIBO)';

DESCRIBE FIELD PUNTO_SALIDA TABLE POSICION_SUCURSAL
'Indica cual es la posicion sucursal por defecto para realizar
las ventas.';

DESCRIBE FIELD IMPUESTO_IVA TABLE PRECIO
'En coeficiente';

DESCRIBE FIELD IMPUESTO_ADICIONAL1 TABLE PRECIO
'En coeficiente';

DESCRIBE FIELD IMPUESTO_ADICIONAL2 TABLE PRECIO
'En coeficiente';

DESCRIBE FIELD PRECIO_COSTO TABLE PRODUCTO
'Preci de costo neto del producto';

DESCRIBE FIELD LLEVAR_STOCK TABLE PRODUCTO
'Indica si se lleva el control del stock del producto o no';

DESCRIBE FIELD PRECIO_COSTO_CIMPUESTOS TABLE PRODUCTO
'El precio de costo del producto con los impuestos incluidos
(impuesto_adicional1, impuesto_adicional2 y/o impuesto_iva)';

DESCRIBE FIELD IMPUESTO_ADICIONAL1 TABLE PRODUCTO
'Impuesto adicional que se suma al precio de costo neto para obtener el
precio de cosot con impustos';

DESCRIBE FIELD IMPUESTO_ADICIONAL2 TABLE PRODUCTO
'Impuesto adicional que se suma al precio de costo neto para obtener el
precio de cosot con impustos';

DESCRIBE FIELD SIGNO_COBRO_PAGO TABLE TIPO_COMPROBANTE
'Como se ve afectada nuestras cuentas segun el tipo de comprobante';

DESCRIBE FIELD SIGNO_STOCK TABLE TIPO_COMPROBANTE
'Como se ve afectado el stock del producto segun el tipo de comprobante';

DESCRIBE FIELD "IF" TABLE TIPO_FORMAPAGO
'Se imprime en Impresora Fiscal o no';

DESCRIBE FIELD DESC_REC TABLE TIPO_FORMAPAGO
'Coeficiente de Descuento o recargo de la forma de pago';

DESCRIBE FIELD COLUMNA_PRECIO TABLE TIPO_FORMAPAGO
'Columna_precio=0 toma el PRECIO_VENTA en las formas de pago';



/******************************************************************************/
/***                        Parameters descriptions                         ***/
/******************************************************************************/

DESCRIBE PARAMETER TIPO PROCEDURE CALC_CTACTE_GENERAL
'0 para clientes, 1 para proveedores';

DESCRIBE PARAMETER ACCION PROCEDURE DEVOLUCION_UPDATE_STOCK
'1 = Confirmar; 2 = Anular';

DESCRIBE PARAMETER INTERVALO PROCEDURE ESTADISTICA_VENTAS_POR_HORA
'Intervalo expresado en minutos';

DESCRIBE PARAMETER RESULTADO PROCEDURE VALIDAR_DEMO_SISTEMA
'0 = el sistema sigue funcionando, 1 = el sistema no funciona';

